This document outlines conventions, patterns, and anti-patterns for Gleam code.
Conventions and anti-patterns are rules that should be adhered to always, while
patterns are to applied whenever the programmer thinks it would benefit their
code.

## Conventions

Gleam enforces `snake_case` for variables, constants, and functions, and
`PascalCase` for types and variants.

### Avoid unqualified importing of functions and constants

Always used the qualified syntax for functions and constants defined in other
modules.

```gleam
// Good
import gleam/list
import gleam/string

pub fn reverse(input: String) -> String {
  input
  |> string.to_graphemes
  |> list.reverse
  |> string.concat
}

// Bad
import gleam/list.{reverse}
import gleam/string.{to_graphemes, concat}

pub fn reverse(input: String) -> String {
  input
  |> to_graphemes
  |> reverse
  |> concat
}
```

Types and record constructors may be used with the unqualified syntax,
providing you think it does not make the code more difficult to read.

### Annotate all module functions

All module functions should have annotations for their argument types and for
their return type.

```gleam
// Good
fn calculate_total(amounts: List(Float), service_charge: Float) -> Float {
  list.fold(amounts, 0, int.add) * service_charge
}

// Bad
fn calculate_total(amounts, service_charge) {
  list.fold(amounts, 0, int.add) * service_charge
}

// Bad: missing return annotation
fn calculate_total(amounts: List(Float), service_charge: Float) {
  list.fold(amounts, 0, int.add) * service_charge
}
```

### Use result for fallible functions

All functions that can succeed or fail may return a result in Gleam.

Some languages use both the result and the option type for fallible functions,
but Gleam does not. Using results always makes code consistent and removes the
boilerplate that would otherwise be required to convert between result and
option. If there is no extra information to return for failure then the result
error type can be `Nil`.

Panics are not used for fallible functions, especially within libraries.
Panicking may be appropriate at the top level of application code, handling the
result returned by fallible functions.

```gleam
// Good
pub fn first(list: List(a)) -> Result(a, Nil) {
  case list {
    [item, ..] -> Ok(item)
    _ -> Error(Nil)
  }
}

// Bad: options
pub fn first(list: List(a)) -> option.Option(a) {
  case list {
    [item, ..] -> option.Some(item)
    _ -> option.None
  }
}

// Bad: panics/exceptions
pub fn first(list: List(a)) -> Result(a, Nil) {
  case list {
    [item, ..] -> item
    _ -> panic as "cannot get first of empty list"
  }
}
```

### Use singular for module names

Module names are singular, not plural.

```gleam
// Good
import app/user

// Bad
import app/users
```

This applies to all segments, not just the final one.

```gleam
// Good
import app/payment/invoice

// Bad
import app/payments/invoice
```

### Treat acronyms as single words

Acronyms are always written as if they were a single word.

```gleam
// Good
let json: Json = build_json()

// Bad
let j_s_o_n: JSON = build_j_s_o_n()
```

It may be tempting to ignore this convention and use the name `JSON`, but this
will result in the BEAM code generated from the Gleam code using the name
`j_s_o_n`.

### Name conversion functions as prescribed

When naming a function that converts from one type to another, use the convention `x_to_y`.

```gleam
// Good
pub fn json_to_string(data: Json) -> String

// Bad
pub fn json_into_string(data: Json) -> String
pub fn json_as_string(data: Json) -> String
pub fn string_of_json(data: Json) -> String
```

If the module name matches the type name then do not repeat the name of the
type at the start of the function.

```gleam
// In src/my_app/identifier.gleam

// Good
pub fn to_string(id: Identifier) -> String

// Bad
pub fn identifier_to_string(id: Identifier) -> String
```
```gleam
import my_app/identifier.{type Identifier}

pub fn run(id: Identifier) -> String {
  identifier.to_string(id)
}
```

If there is a name for the encoding, format, or variant used in the conversion
function, then use that in the name of the function.

```gleam
// Good
pub fn date_to_rfc3339(date: Date) -> String

// Bad
pub fn date_to_string(date: Date) -> String
```

If there is a more descriptive name for the conversion operation then use that
instead.

```gleam
// Good
pub fn round(data: Float) -> Int

// Bad
pub fn float_to_int(data: Float) -> Int
```

### Name short-circuiting result functions as prescribed

Functions that return results should be given a name that is appropriate for
the domain and the operation they perform.

```gleam
// Good
pub fn parse_json(input: String) -> Result(Json, ParseError)
pub fn enqueue(job: BackgroundJob) -> Result(Nil, EnqueueError)
```

If the function is a special result-handling version of an existing function
that short-circuits when there is an error, then the `try_` prefix can be used,
so long as there is not a more appropriate domain-specific name. Names based on
design patterns or abstract concepts should be avoided.

```gleam
pub fn map(list: List(a), f: fn(a) -> b) -> List(b)

// Good
pub fn try_map(
  list: List(a),
  f: fn(a) -> Result(b, e),
) -> Result(List(b), e)

// Bad
pub fn monadic_bind(
  list: List(a),
  f: fn(a) -> Result(b, e),
) -> Result(List(b), e)
```

### Use the core libraries

## Patterns

### Comment liberally

Comments are a very effective way to make code easier to understand, and they
take little time to write, so comments can be a very efficient way to make code
easier to work with.

Comments can explain both _what_ the code does as well as _why_ the code does
what it does. Often the reader could determine _what_ without the aid of the
comment, but that may not be the case for unfamiliar readers, or if the code is
later determined to have a bug, so what it does and what the writer intended it
to do do not match.

```gleam
pub fn classify_file_content(content: String) -> FileOrigin {
  let likely_generated =
    // In newer versions of squirrel this is always at the beginning of the
    // file and it would be enough to check for this comment to establish if
    // a file is generated or not...
    string.contains(
      content,
      "> ðŸ¿ï¸ This module was generated automatically using",
    )
    // ...but in older versions that module comment is not present! So we
    // need to check if there's any function generated by squirrel.
    || string.contains(
      content,
      "> ðŸ¿ï¸ This function was generated automatically using",
    )

  case likely_generated {
    True -> LikelyGenerated
    False -> NotGenerated
  }
}
```

Adding comments does not mean the code itself can be written in an unclear way,
and having well written code doesn't mean that comments are not a valuable
addition.

### Make invalid states impossible

TODO

### Replace bools with custom types

TODO

### Match all variants

TODO

### The sans-io pattern

TODO

### The builder pattern

TODO

## Anti-patterns

### Fragmented modules

TODO

### Panicking in libraries

Libraries must not panic, so they should not use `panic` or `let assert`.

Panicking instead of returning a result takes control away from the users of
the library, preventing them from being able to handle errors. A library does
not know the context in which it is used, so it is impossible for the author of
a library to know if it acceptable to panic, so they never can.

The one exception to this rule is for libraries _about_ OTP, the BEAM
application framework. OTP has non-local handling through supervision trees, so
there may be some circumstances in which it is appropriate to panic, providing
they have a suitably designed supervision tree. The library author would
benefit from having a strong understanding of OTP system to identify when this
is a good option.

### Check-then-assert

TODO

### Global namespace pollution

TODO

### Namespace trespassing

TODO

### Using dynamic with FFI

TODO

### Category theory naming

## OTP anti-patterns

### Processes as state

TODO

### Unsupervised processes

TODO

### Large messages

TODO

### Organising code with processes

TODO
