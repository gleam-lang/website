## Conventions

Gleam enforces `snake_case` for variables, constants, and functions, and
`PascalCase` for types and variants.

### Use result for fallible functions

All functions that can succeed or fail my return a result in Gleam.

Some languages use both the result and the option type for fallible functions,
but Gleam does not. Using results always makes code consistent and removes the
boilerplate that would otherwise be required to convert between result and
option. If there is no extra information to return for failure then the result
error type can be `Nil`.

Panics are not used for fallible functions, especially within libraries.
Panicking may be appropriate at the top level of application code, handling the
result returned by fallible functions.

```gleam
// Good
pub fn first(list: List(a)) -> Result(a, Nil) {
  case list {
    [item, ..] -> Ok(item)
    _ -> Error(Nil)
  }
}

// Bad: panics/exceptions
pub fn first(list: List(a)) -> option.Option(a) {
  case list {
    [item, ..] -> option.Some(item)
    _ -> option.None
  }
}

// Bad: panics/exceptions
pub fn first(list: List(a)) -> Result(a, Nil) {
  case list {
    [item, ..] -> item
    _ -> panic as "cannot get first of empty list"
  }
}
```


TODO

### Use singular for module names

TODO

### Treat acronyms as single words

Acronyms are always written as if they were a single word.

```gleam
// Good
let json: Json = build_json()

// Bad
let j_s_o_n: JSON = build_j_s_o_n()
```

It may be tempting to ignore this convention and use the name `JSON`, but this
will result in the BEAM code generated from the Gleam code using the name
`j_s_o_n`.

### Name conversion functions as prescribed

When naming a function that converts from one type to another, use the convention `x_to_y`.

```gleam
// Good
pub fn json_to_string(data: Json) -> String

// Bad
pub fn json_into_string(data: Json) -> String
pub fn json_as_string(data: Json) -> String
pub fn string_of_json(data: Json) -> String
```

If the module name matches the type name then do not repeat the name of the
type at the start of the function.

```gleam
// In src/my_app/identifier.gleam

// Good
pub fn to_string(id: Identifier) -> String

// Bad
pub fn identifier_to_string(id: Identifier) -> String
```
```gleam
import my_app/identifier.{type Identifier}

pub fn run(id: Identifier) -> String {
  identifier.to_string(id)
}
```

If there is a name for the encoding, format, or variant used in the conversion
function, then use that in the name of the function.

```gleam
// Good
pub fn date_to_string(date: Date) -> String

// Bad
pub fn date_to_rfc3339(date: Date) -> String
```

If there is a more descriptive name ggfor the conversion operation then use that
instead.

```gleam
// Good
pub fn round(data: Float) -> Int

// Bad
pub fn float_to_int(data: Float) -> Int
```

### Name short-circuiting result functions as prescribed

TODO

## Patterns

### Comment liberally

Comments are a very effective way to make code easier to understand, and they
take little time to write, so comments can be a very efficient way to make code
easier to work with.

Comments can explain both _what_ the code does as well as _why_ the code does
what it does. Often the reader could determine _what_ without the aid of the
comment, but that may not be the case for unfamiliar readers, or if the code is
later determined to have a bug, so what it does and what the writer intended it
to do do not match.

```gleam
pub fn classify_file_content(content: String) -> FileOrigin {
  let likely_generated =
    // In newer versions of squirrel this is always at the beginning of the
    // file and it would be enough to check for this comment to establish if
    // a file is generated or not...
    string.contains(
      content,
      "> ðŸ¿ï¸ This module was generated automatically using",
    )
    // ...but in older versions that module comment is not present! So we
    // need to check if there's any function generated by squirrel.
    || string.contains(
      content,
      "> ðŸ¿ï¸ This function was generated automatically using",
    )

  case likely_generated {
    True -> LikelyGenerated
    False -> NotGenerated
  }
}
```

Adding comments does not mean the code itself can be written in an unclear way,
and having well written code doesn't mean that comments are not a valuable
addition.

### Make invalid states impossible

TODO

### Replace bools with custom types

TODO

### Match all variants

TODO

### Sans-io

TODO

## Anti-patterns

### Fragmented modules

TODO

### Panicking in libraries

Libraries must not panic, so they should not use `panic` or `let assert`.

Panicking instead of returning a result takes control away from the users of
the library, preventing them from being able to handle errors. A library does
not know the context in which it is used, so it is impossible for the author of
a library to know if it acceptable to panic, so they never can.

The one exception to this rule is for libraries _about_ OTP, the BEAM
application framework. OTP has non-local handling through supervision trees, so
there may be some circumstances in which it is appropriate to panic, providing
they have a suitably designed supervision tree. The library author would
benefit from having a strong understanding of OTP system to identify when this
is a good option.

### Check-then-assert

TODO

### Global namespace pollution

TODO

### Namespace trespassing

TODO

### Using dynamic with FFI

TODO

### Category theory naming

## OTP anti-patterns

### Processes as state

TODO

### Unsupervised processes

TODO

### Large messages

TODO

### Organising code with processes

TODO
