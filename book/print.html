<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Gleam Book</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="tour/index.html"><strong aria-hidden="true">1.</strong> Language tour</a></li><li class="chapter-item expanded "><a href="tour/comments.html"><strong aria-hidden="true">2.</strong> Comments</a></li><li class="chapter-item expanded "><a href="tour/strings.html"><strong aria-hidden="true">3.</strong> Strings</a></li><li class="chapter-item expanded "><a href="tour/bools.html"><strong aria-hidden="true">4.</strong> Bools</a></li><li class="chapter-item expanded "><a href="tour/ints-and-floats.html"><strong aria-hidden="true">5.</strong> Ints &amp; Floats</a></li><li class="chapter-item expanded "><a href="tour/let-bindings.html"><strong aria-hidden="true">6.</strong> Let bindings</a></li><li class="chapter-item expanded "><a href="tour/expression-blocks.html"><strong aria-hidden="true">7.</strong> Expression blocks</a></li><li class="chapter-item expanded "><a href="tour/lists.html"><strong aria-hidden="true">8.</strong> Lists</a></li><li class="chapter-item expanded "><a href="tour/tuples.html"><strong aria-hidden="true">9.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="tour/case-expressions.html"><strong aria-hidden="true">10.</strong> Case expressions</a></li><li class="chapter-item expanded "><a href="tour/functions.html"><strong aria-hidden="true">11.</strong> Functions</a></li><li class="chapter-item expanded "><a href="tour/modules.html"><strong aria-hidden="true">12.</strong> Modules</a></li><li class="chapter-item expanded "><a href="tour/custom-types.html"><strong aria-hidden="true">13.</strong> Custom types</a></li><li class="chapter-item expanded "><a href="tour/result.html"><strong aria-hidden="true">14.</strong> Result</a></li><li class="chapter-item expanded "><a href="tour/try.html"><strong aria-hidden="true">15.</strong> Try</a></li><li class="chapter-item expanded "><a href="tour/assert.html"><strong aria-hidden="true">16.</strong> Assert</a></li><li class="chapter-item expanded "><a href="tour/todo.html"><strong aria-hidden="true">17.</strong> Todo</a></li><li class="chapter-item expanded "><a href="tour/constants.html"><strong aria-hidden="true">18.</strong> Constants</a></li><li class="chapter-item expanded "><a href="tour/type-aliases.html"><strong aria-hidden="true">19.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="tour/bit-strings.html"><strong aria-hidden="true">20.</strong> Bit strings</a></li><li class="chapter-item expanded "><a href="tour/external-functions.html"><strong aria-hidden="true">21.</strong> External functions</a></li><li class="chapter-item expanded "><a href="tour/external-types.html"><strong aria-hidden="true">22.</strong> External types</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Gleam Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gleam-lang/website" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="language-tour"><a class="header" href="#language-tour">Language Tour</a></h1>
<p>In this book we explore the fundamentals of the Gleam language, namely its
syntax, core data structures, flow control features, and static type system.
If you have some prior programming experience this will hopefully be enough
to get you started with Gleam.</p>
<p>In some sections we touch on the runtime representation of various features.
This is useful for programmers with Erlang or Elixir experience who wish to
use Gleam alongside these languages. If you are using Gleam alone this
information can be safely ignored.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments"><a class="header" href="#comments">Comments</a></h1>
<p>Gleam allows you to write comments in your code.</p>
<p>Here‚Äôs a simple comment:</p>
<pre><code class="language-gleam">// Hello, world!
</code></pre>
<p>In Gleam, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you‚Äôll need to include
<code>//</code> on each line, like this:</p>
<pre><code class="language-gleam">// Hello, world! I have a lot to say, so much that it will take multiple
// lines of text. Therefore, I will start each line with // to denote it
// as part of a multi-line comment.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-gleam">pub fn add(x, y) {
  x + y // here we are adding two values together
}
</code></pre>
<p>Comments may also be indented:</p>
<pre><code class="language-gleam">pub fn multiply(x, y) {
  // here we are multiplying x by y
  x * y
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="strings"><a class="header" href="#strings">Strings</a></h1>
<p>In Gleam Strings can be written as text surrounded by double quotes.</p>
<pre><code class="language-gleam">&quot;Hello, Gleam!&quot;
</code></pre>
<p>They can span multiple lines.</p>
<pre><code class="language-gleam">&quot;Hello
Gleam!&quot;
</code></pre>
<p>Under the hood Strings are <a href="https://en.wikipedia.org/wiki/UTF-8">UTF-8</a> encoded binaries
and can contain any valid unicode.</p>
<pre><code class="language-gleam">&quot;üë©‚Äçüíª „Åì„Çì„Å´„Å°„ÅØ Gleam üí´&quot;
</code></pre>
<h2 id="escape-sequences"><a class="header" href="#escape-sequences">Escape Sequences</a></h2>
<p>Gleam supports common string escape sequences. Here's all of them:</p>
<table><thead><tr><th>Sequence</th><th>Result</th></tr></thead><tbody>
<tr><td><code>\n</code></td><td>Newline</td></tr>
<tr><td><code>\r</code></td><td>Carriage Return</td></tr>
<tr><td><code>\t</code></td><td>Tab</td></tr>
<tr><td><code>\&quot;</code></td><td>Double Quote</td></tr>
<tr><td><code>\\</code></td><td>Backslash</td></tr>
</tbody></table>
<p>For example to include a double quote (<code>&quot;</code>) character in a string literal it
must be escaped by placing a backslash (<code>\</code>) character before it.</p>
<pre><code class="language-gleam">&quot;Here is a double quote -&gt; \&quot; &lt;-&quot;
</code></pre>
<p>Similarly all backslash characters must be escaped:</p>
<pre><code class="language-gleam">// A Windows filepath C:\Users\Gleam
&quot;C:\\Users\\Gleam&quot;

// A Decorative border /\/\/\/\
&quot;/\\/\\/\\/\\&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bool"><a class="header" href="#bool">Bool</a></h1>
<p>A Bool can be either <code>True</code> or <code>False</code>.</p>
<p>Gleam defines a handful of operators that work with Bools.</p>
<pre><code class="language-gleam">False &amp;&amp; False // =&gt; False
False &amp;&amp; True  // =&gt; False
True &amp;&amp; False  // =&gt; False
True &amp;&amp; True   // =&gt; True

False || False // =&gt; False
False || True  // =&gt; True
True || False  // =&gt; True
True || True   // =&gt; True
</code></pre>
<p><code>&amp;&amp;</code> and <code>||</code> are <em>short circuiting</em>, meaning they don't evaluate the right
hand side if they don't have to.</p>
<p><code>&amp;&amp;</code> evaluates the right hand side if the left hand side is <code>True</code>.</p>
<p><code>||</code> evaluates the right hand side if the left hand side is <code>False</code>.</p>
<p>Gleam supports negation of Bools using either the <code>!</code> operator or the
<code>bool.negate</code> function from the <code>gleam/bool</code> module.</p>
<pre><code class="language-gleam">!True  // =&gt; False
!False // =&gt; True
</code></pre>
<h2 id="erlang-interop"><a class="header" href="#erlang-interop">Erlang interop</a></h2>
<p>While written in the code using a capital letter, they are represented at
runtime with the atoms <code>true</code> and <code>false</code>, making them compatible with Elixir
and Erlang's booleans.</p>
<p>This is important if you want to use Gleam and Elixir or Erlang together in
one project.</p>
<pre><code class="language-gleam">// Gleam
True
False
</code></pre>
<pre><code class="language-erlang">% Erlang
true.
false.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="int-and-float"><a class="header" href="#int-and-float">Int and Float</a></h1>
<p>Gleam's main number types are Int and Float.</p>
<h2 id="ints"><a class="header" href="#ints">Ints</a></h2>
<p>Ints are &quot;whole&quot; numbers.</p>
<p>Binary, octal, and hexadecimal ints begin with <code>0b</code>, <code>0o</code>, and <code>0x</code> respectively.</p>
<pre><code class="language-gleam">1
2
-3
4001
0b00001111
0o17
0xF
</code></pre>
<p>Gleam has several operators that work with Ints.</p>
<pre><code class="language-gleam">1 + 1 // =&gt; 2
5 - 1 // =&gt; 4
5 / 2 // =&gt; 2
3 * 3 // =&gt; 9
5 % 2 // =&gt; 1

2 &gt; 1  // =&gt; True
2 &lt; 1  // =&gt; False
2 &gt;= 1 // =&gt; True
2 &lt;= 1 // =&gt; False
</code></pre>
<p>Underscores can be added to Ints for clarity.</p>
<pre><code class="language-gleam">1_000_000 // One million
</code></pre>
<h2 id="floats"><a class="header" href="#floats">Floats</a></h2>
<p>Floats are numbers that have a decimal point.</p>
<pre><code class="language-gleam">1.5
2.0
-0.1
</code></pre>
<p>Floats also have their own set of operators.</p>
<pre><code class="language-gleam">1.0 +. 1.4 // =&gt; 2.4
5.0 -. 1.5 // =&gt; 3.5
5.0 /. 2.0 // =&gt; 2.5
3.0 *. 3.1 // =&gt; 9.3

2.0 &gt;. 1.0  // =&gt; True
2.0 &lt;. 1.0  // =&gt; False
2.0 &gt;=. 1.0 // =&gt; True
2.0 &lt;=. 1.0 // =&gt; False
</code></pre>
<p>Underscores can also be added to Floats for clarity.</p>
<pre><code class="language-gleam">1_000_000.0 // One million
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="let-bindings"><a class="header" href="#let-bindings">Let bindings</a></h1>
<p>A value can be given a name using <code>let</code>. Names can be reused by later let
bindings, but the values contained are <em>immutable</em>, meaning the values
themselves cannot be changed.</p>
<pre><code class="language-gleam">let x = 1
let y = x
let x = 2

x  // =&gt; 2
y  // =&gt; 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expression-blocks"><a class="header" href="#expression-blocks">Expression blocks</a></h1>
<p>Every block in Gleam is an expression. All expressions in the block are
executed, and the result of the last expression is returned.</p>
<pre><code class="language-gleam">let value: Bool = {
    &quot;Hello&quot;
    42 + 12
    False
} // =&gt; False
</code></pre>
<p>Expression blocks can be used instead of parenthesis to change the precedence
of operations.</p>
<pre><code class="language-gleam">let celsius = { fahrenheit - 32 } * 5 / 9
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="list"><a class="header" href="#list">List</a></h1>
<p>Lists are ordered collections of values. They're one of the most common data
structures in Gleam.</p>
<p>Lists are <em>homogeneous</em>, meaning all the elements of a List must be of the
same type. Attempting to construct a list of multiple types of element will
result in the compiler presenting a type error.</p>
<pre><code class="language-gleam">[1, 2, 3, 4]  // List(Int)
[1.22, 2.30]  // List(Float)
[1.22, 3, 4]  // Type error!
</code></pre>
<p>Prepending to a list is very fast, and is the preferred way to add new values.</p>
<pre><code class="language-gleam">[1, ..[2, 3]]  // =&gt; [1, 2, 3]
</code></pre>
<p>Note that all data structures in Gleam are immutable so prepending to a list
does not change the original list. Instead it efficiently creates a new list
with the new additional element.</p>
<pre><code class="language-gleam">let x = [2, 3]
let y = [1, ..x]


x  // =&gt; [2, 3]
y  // =&gt; [1, 2, 3]
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tuples"><a class="header" href="#tuples">Tuples</a></h1>
<p>Lists are good for when we want a collection of one type, but sometimes we want
to combine multiple values of different types. In this case tuples are a quick
and convenient option.</p>
<p>Gleam provides two ways to construct or match on tuples: the <code>#(1, 2, 3)</code> format,
introduced in Gleam 0.15.0, and the original <code>tuple(1, 2, 3)</code> format which will
be removed in a future version of Gleam.</p>
<pre><code class="language-gleam">#(10, &quot;hello&quot;) // Type is #(Int, String)
#(1, 4.2, [0]) // Type is #(Int, Float, List(Int))
</code></pre>
<p>Once you have a tuple the values contained can be accessed using the <code>.0</code>
accessor syntax.</p>
<pre><code class="language-gleam">let my_tuple = #(&quot;one&quot;, &quot;two&quot;)
let first = my_tuple.0   // &quot;one&quot;
let second = my_tuple.1 // &quot;two&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="case"><a class="header" href="#case">Case</a></h1>
<p>The <code>case</code> expression is the most common kind of flow control in Gleam code. It
allows us to say &quot;if the data has this shape then do that&quot;, which we call
<em>pattern matching</em>.</p>
<p>Here we match on an <code>Int</code> and return a specific string for the values 0, 1,
and 2. The final pattern <code>n</code> matches any other value that did not match any of
the previous patterns.</p>
<pre><code class="language-gleam">case some_number {
  0 -&gt; &quot;Zero&quot;
  1 -&gt; &quot;One&quot;
  2 -&gt; &quot;Two&quot;
  n -&gt; &quot;Some other number&quot; // This matches anything
}
</code></pre>
<p>Pattern matching on a <code>Bool</code> value is the Gleam alternative to the <code>if else</code>
statement found in other languages.</p>
<pre><code class="language-gleam">case some_bool {
  True -&gt; &quot;It's true!&quot;
  False -&gt; &quot;It's not true.&quot;
}
</code></pre>
<p>Gleam's <code>case</code> is an expression, meaning it returns a value and can be used
anywhere we would use a value. For example, we can name the value of a case
expression with a <code>let</code> binding.</p>
<pre><code class="language-gleam">let description =
  case True {
    True -&gt; &quot;It's true!&quot;
    False -&gt; &quot;It's not true.&quot;
  }

description  // =&gt; &quot;It's true!&quot;
</code></pre>
<h2 id="destructuring"><a class="header" href="#destructuring">Destructuring</a></h2>
<p>A <code>case</code> expression can be used to destructure values that
contain other values, such as tuples and lists.</p>
<pre><code class="language-gleam">case xs {
  [] -&gt; &quot;This list is empty&quot;
  [a] -&gt; &quot;This list has 1 element&quot;
  [a, b] -&gt; &quot;This list has 2 elements&quot;
  _other -&gt; &quot;This list has more than 2 elements&quot;
}
</code></pre>
<p>It's not just the top level data structure that can be pattern matched,
contained values can also be matched. This gives <code>case</code> the ability to
concisely express flow control that might be verbose without pattern matching.</p>
<pre><code class="language-gleam">case xs {
  [[]] -&gt; &quot;The only element is an empty list&quot;
  [[], ..] -&gt; &quot;The 1st element is an empty list&quot;
  [[4], ..] -&gt; &quot;The 1st element is a list of the number 4&quot;
  other -&gt; &quot;Something else&quot;
}
</code></pre>
<p>Pattern matching also works in <code>let</code> bindings, though patterns that do not
match all instances of that type may result in a runtime error.</p>
<pre><code class="language-gleam">let [a] = [1]    // a is 1
let [b] = [1, 2] // Runtime error! The pattern has 1 element but the value has 2
</code></pre>
<h2 id="matching-on-multiple-values"><a class="header" href="#matching-on-multiple-values">Matching on multiple values</a></h2>
<p>Sometimes it is useful to pattern match on multiple values at the same time,
so <code>case</code> supports having multiple subjects.</p>
<pre><code class="language-gleam">case x, y {
  1, 1 -&gt; &quot;both are 1&quot;
  1, _ -&gt; &quot;x is 1&quot;
  _, 1 -&gt; &quot;y is 1&quot;
  _, _ -&gt; &quot;neither is 1&quot;
}
</code></pre>
<h2 id="assigning-names-to-sub-patterns"><a class="header" href="#assigning-names-to-sub-patterns">Assigning names to sub-patterns</a></h2>
<p>Sometimes when pattern matching we want to assign a name to a value while
specifying its shape at the same time. We can do this using the <code>as</code> keyword.</p>
<pre><code class="language-gleam">case xs {
  [[_, ..] as inner_list] -&gt; inner_list
  other -&gt; []
}
</code></pre>
<h2 id="checking-equality-and-ordering-in-patterns"><a class="header" href="#checking-equality-and-ordering-in-patterns">Checking equality and ordering in patterns</a></h2>
<p>The <code>if</code> keyword can be used to add a guard expression to a case clause. Both
the patterns have to match and the guard has to evaluate to <code>True</code> for the
clause to match. The guard expression can check for equality or ordering for
<code>Int</code> and <code>Float</code>.</p>
<pre><code class="language-gleam">case xs {
  [a, b, c] if a == b &amp;&amp; b != c -&gt; &quot;ok&quot;
  _other -&gt; &quot;ko&quot;
}
</code></pre>
<pre><code class="language-gleam">case xs {
  [a, b, c] if a &gt;. b &amp;&amp; a &lt;=. c -&gt; &quot;ok&quot;
  _other -&gt; &quot;ko&quot;
}
</code></pre>
<h2 id="alternative-clause-patterns"><a class="header" href="#alternative-clause-patterns">Alternative clause patterns</a></h2>
<p>Alternative patterns can be given for a case clause using the <code>|</code> operator. If
any of the patterns match then the clause matches.</p>
<p>Here the first clause will match if the variable <code>number</code> holds 2, 4, 6 or 8.</p>
<pre><code class="language-gleam">case number {
  2 | 4 | 6 | 8 -&gt; &quot;This is an even number&quot;
  1 | 3 | 5 | 7 -&gt; &quot;This is an odd number&quot;
  _ -&gt; &quot;I'm not sure&quot;
}
</code></pre>
<p>If the patterns declare variables then the same variables must be declared in
all patterns, and the variables must have the same type in all the patterns.</p>
<pre><code class="language-gleam">case list {
  [1, x] | x -&gt; x // Error! Int != List(Int)
  _ -&gt; 0
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<h2 id="named-functions"><a class="header" href="#named-functions">Named functions</a></h2>
<p>Named functions in Gleam are defined using the <code>pub fn</code> keywords.</p>
<pre><code class="language-gleam">pub fn add(x: Int, y: Int) -&gt; Int {
  x + y
}

pub fn multiply(x: Int, y: Int) -&gt; Int {
  x * y
}
</code></pre>
<p>Functions in Gleam are first class values and so can be assigned to variables,
passed to functions, or anything else you might do with any other data type.</p>
<pre><code class="language-gleam">/// This function takes a function as an argument
pub fn twice(f: fn(t) -&gt; t, x: t) -&gt; t {
  f(f(x))
}

pub fn add_one(x: Int) -&gt; Int {
  x + 1
}

pub fn add_two(x: Int) -&gt; Int {
  twice(add_one, x)
}
</code></pre>
<h2 id="pipe-operator"><a class="header" href="#pipe-operator">Pipe Operator</a></h2>
<p>Gleam provides syntax for passing the result of one function to the arguments of another function, the pipe operator (<code>|&gt;</code>). This is similar in functionality to the same operator in Elixir or F#.</p>
<p>The pipe operator allows you to chain function calls without using a plethora of parenthesis. For a simple example, consider the following implementation of <code>string.reverse</code> in Gleam:</p>
<pre><code class="language-gleam">string_builder.to_string(string_builder.reverse(string_builder.new(string)))
</code></pre>
<p>This can be expressed more naturally using the pipe operator, eliminating the need to track parenthesis closure.</p>
<pre><code class="language-gleam">string
|&gt; string_builder.new
|&gt; string_builder.reverse
|&gt; string_builder.to_string
</code></pre>
<p>Each line of this expression applies the function to the result of the previous line. This works easily because each of these functions take only one argument. Syntax is available to substitute specific arguments of functions that take more than one argument; for more, look below in the section &quot;Function capturing&quot;.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type annotations</a></h2>
<p>Function arguments are normally annotated with their type, and the
compiler will check these annotations and ensure they are correct.</p>
<pre><code class="language-gleam">fn identity(x: some_type) -&gt; some_type {
  x
}

fn inferred_identity(x) {
  x
}
</code></pre>
<p>The Gleam compiler can infer all the types of Gleam code without annotations
and both annotated and unannotated code is equally safe. It's considered a
best practice to always write type annotations for your functions as they
provide useful documentation, and they encourage thinking about types as code
is being written.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic functions</a></h2>
<p>At times you may wish to write functions that are generic over multiple types.
For example, consider a function that consumes any value and returns a list
containing two of the value that was passed in. This can be expressed in Gleam
like this:</p>
<pre><code class="language-gleam">fn list_of_two(my_value: a) -&gt; List(a) {
  [my_value, my_value]
}
</code></pre>
<p>Here the type variable <code>a</code> is used to represent any possible type.</p>
<p>You can use any number of different type variables in the same function. This
function declares type variables <code>a</code> and <code>b</code>.</p>
<pre><code class="language-gleam">fn multi_result(x: a, y: b, condition: Bool) -&gt; Result(a, b) {
  case condition {
    True -&gt; Ok(x)
    False -&gt; Error(y)
  }
}
</code></pre>
<p>Type variables can be named anything, but the names must be lower case and may
contain underscores. Like other type annotations, they are completely optional,
but may aid in understanding the code.</p>
<h2 id="labelled-arguments"><a class="header" href="#labelled-arguments">Labelled arguments</a></h2>
<p>When functions take several arguments it can be difficult for the user to
remember what the arguments are, and what order they are expected in.</p>
<p>To help with this Gleam supports <em>labelled arguments</em>, where function
arguments are given an external label in addition to their internal name.</p>
<p>Take this function that replaces sections of a string:</p>
<pre><code class="language-gleam">pub fn replace(string: String, pattern: String, replacement: String) {
  // ...
}
</code></pre>
<p>It can be given labels like so.</p>
<pre><code class="language-gleam">pub fn replace(
  in string: String,
  each pattern: String,
  with replacement: String,
) {
  // The variables `string`, `pattern`, and `replacement` are in scope here
}
</code></pre>
<p>These labels can then be used when calling the function.</p>
<pre><code class="language-gleam">replace(in: &quot;A,B,C&quot;, each: &quot;,&quot;, with: &quot; &quot;)

// Labelled arguments can be given in any order
replace(each: &quot;,&quot;, with: &quot; &quot;, in: &quot;A,B,C&quot;)

// Arguments can still be given in a positional fashion
replace(&quot;A,B,C&quot;, &quot;,&quot;, &quot; &quot;)
</code></pre>
<p>The use of argument labels can allow a function to be called in an expressive,
sentence-like manner, while still providing a function body that is readable
and clear in intent.</p>
<h2 id="anonymous-functions"><a class="header" href="#anonymous-functions">Anonymous functions</a></h2>
<p>Anonymous functions can be defined with a similar syntax.</p>
<pre><code class="language-gleam">pub fn run() {
  let add = fn(x, y) { x + y }

  add(1, 2)
}
</code></pre>
<h2 id="function-capturing"><a class="header" href="#function-capturing">Function capturing</a></h2>
<p>There is a shorthand syntax for creating anonymous functions that take one
argument and call another function. The <code>_</code> is used to indicate where the
argument should be passed.</p>
<pre><code class="language-gleam">pub fn add(x, y) {
  x + y
}

pub fn run() {
  let add_one = add(1, _)

  add_one(2)
}
</code></pre>
<p>The function capture syntax is often used with the pipe operator to create
a series of transformations on some data.</p>
<pre><code class="language-gleam">pub fn add(x: Int , y: Int ) -&gt; Int {
  x + y
}

pub fn run() {
  // This is the same as add(add(add(1, 3), 6), 9)
  1
  |&gt; add(_, 3)
  |&gt; add(_, 6)
  |&gt; add(_, 9)
}
</code></pre>
<p>In fact, this usage is so common that there is a special shorthand for it.</p>
<pre><code class="language-gleam">pub fn run() {
  // This is the same as the example above
  1
  |&gt; add(3)
  |&gt; add(6)
  |&gt; add(9)
}
</code></pre>
<p>The pipe operator will first check to see if the left hand value could be used
as the first argument to the call, e.g. <code>a |&gt; b(1, 2)</code> would become <code>b(a, 1, 2)</code>.</p>
<p>If not it falls back to calling the result of the right hand side as a function
, e.g. <code>b(1, 2)(a)</code>.</p>
<h2 id="documentation"><a class="header" href="#documentation">Documentation</a></h2>
<p>You may add user facing documentation in front of function definitions with a
documentation comment <code>///</code> per line. Markdown is supported and this text
will be included with the module's entry in generated HTML documentation.</p>
<pre><code class="language-gleam">/// Does nothing, returns `Nil`.
///
fn returns_nil(a) -&gt; Nil {
  Nil
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="modules"><a class="header" href="#modules">Modules</a></h1>
<p>Gleam programs are made up of bundles of functions and types called modules.
Each module has its own namespace and can export types and values to be used
by other modules in the program.</p>
<pre><code class="language-gleam">// inside module src/nasa/rocket_ship.gleam

fn count_down() {
  &quot;3... 2... 1...&quot;
}

fn blast_off() {
  &quot;BOOM!&quot;
}

pub fn launch() {
  [
    count_down(),
    blast_off(),
  ]
}
</code></pre>
<p>Here we can see a module named <code>nasa/rocket_ship</code>, the name determined by the
filename <code>src/nasa/rocket_ship.gleam</code>. Typically all the modules for one
project would live within a directory with the name of the project, such as
<code>nasa</code> in this example.</p>
<p>For the functions <code>count_down</code> and <code>blast_off</code> we have omitted the <code>pub</code>
keyword, so these functions are <em>private</em> module functions. They can only be
called by other functions within the same module.</p>
<h2 id="import"><a class="header" href="#import">Import</a></h2>
<p>To use functions or types from another module we need to import them using the
<code>import</code> keyword.</p>
<pre><code class="language-gleam">// inside module src/nasa/moon_base.gleam

import nasa/rocket_ship

pub fn explore_space() {
  rocket_ship.launch()
}
</code></pre>
<p>The statement <code>import nasa/rocket_ship</code> creates a new variable with the name
<code>rocket_ship</code> and the value of the <code>rocket_ship</code> module.</p>
<p>In the <code>explore_space</code> function we call the imported module's public <code>launch</code>
function using the <code>.</code> operator. If we had attempted to call <code>count_down</code> it
would result in a compile time error as this function is private to the
<code>rocket_ship</code> module.</p>
<h2 id="named-import"><a class="header" href="#named-import">Named import</a></h2>
<p>It is also possible to give a module a custom name when importing it using the
<code>as</code> keyword.</p>
<pre><code class="language-gleam">import unix/cat
import animal/cat as kitty
</code></pre>
<p>This may be useful to differentiate between multiple modules that would have
the same default name when imported.</p>
<h2 id="unqualified-import"><a class="header" href="#unqualified-import">Unqualified import</a></h2>
<p>Values and types can also be imported in an unqualified fashion.</p>
<pre><code class="language-gleam">import animal/cat.{Cat, stroke}

pub fn main() {
  let kitty = Cat(name: &quot;Nubi&quot;)
  stroke(kitty)
}
</code></pre>
<p>This may be useful for values that are used frequently in a module, but
generally qualified imports are preferred as it makes it clearer where the
value is defined.</p>
<h2 id="the-prelude-module"><a class="header" href="#the-prelude-module">The prelude module</a></h2>
<p>There is one module that is built into the language, the <code>gleam</code> prelude
module.  By default its types and values are automatically imported into
every module you write, but you can still chose to import it the regular way.
This may be useful if you have created a type or value with the same name as
an item from the prelude.</p>
<pre><code class="language-gleam">import gleam

/// This definition locally overrides the `Result` type
/// and the `Ok` constructor.
pub type Result {
  Ok
}

/// The original `Result` and `Ok` can still be used
pub fn go() -&gt; gleam.Result(Int) {
  gleam.Ok(1)
}
</code></pre>
<p>The prelude module contains these types:</p>
<ul>
<li><code>BitString</code></li>
<li><code>Bool</code></li>
<li><code>Float</code></li>
<li><code>Int</code></li>
<li><code>List(element)</code></li>
<li><code>Nil</code></li>
<li><code>Result(value, error)</code></li>
<li><code>String</code></li>
<li><code>UtfCodepoint</code></li>
</ul>
<p>And these values:</p>
<ul>
<li><code>Error</code></li>
<li><code>False</code></li>
<li><code>Nil</code></li>
<li><code>Ok</code></li>
<li><code>True</code></li>
</ul>
<h2 id="documentation-1"><a class="header" href="#documentation-1">Documentation</a></h2>
<p>You may add user facing documentation at the head of modules with a module
documentation comment <code>////</code> per line. Markdown is supported and this text
will be included with the module's entry in generated HTML documentation.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-types"><a class="header" href="#custom-types">Custom types</a></h1>
<p>Gleam's custom types are named collections of keys and values. They are
similar to objects in object oriented languages, though they don't have
methods.</p>
<p>Custom types are defined with the <code>type</code> keyword.</p>
<pre><code class="language-gleam">pub type Cat {
  Cat(name: String, cuteness: Int)
}
</code></pre>
<p>Here we have defined a custom type called <code>Cat</code>. Its constructor is called
<code>Cat</code> and it has two fields: A <code>name</code> field which is a <code>String</code>, and a
<code>cuteness</code> field which is an <code>Int</code>.</p>
<p>The <code>pub</code> keyword makes this type usable from other modules.</p>
<p>Once defined the custom type can be used in functions:</p>
<pre><code class="language-gleam">fn cats() {
  // Labelled fields can be given in any order
  let cat1 = Cat(name: &quot;Nubi&quot;, cuteness: 2001)
  let cat2 = Cat(cuteness: 1805, name: &quot;Biffy&quot;)

  // Alternatively fields can be given without labels
  let cat3 = Cat(&quot;Ginny&quot;, 1950)

  [cat1, cat2, cat3]
}
</code></pre>
<h2 id="multiple-constructors"><a class="header" href="#multiple-constructors">Multiple constructors</a></h2>
<p>Custom types in Gleam can be defined with multiple constructors, making them a
way of modeling data that can be one of a few different variants.</p>
<p>We've already seen a custom type with multiple constructors in the Language
Tour - <a href="tour/./bools.html"><code>Bool</code></a>.</p>
<p>Gleam's built-in <code>Bool</code> type is defined like this:</p>
<pre><code class="language-gleam">// A Bool is a value that is either `True` or `False`
pub type Bool {
  True
  False
}
</code></pre>
<p>It's a simple custom type with constructors that takes no arguments at all!
Use it to answer yes/no questions and to indicate whether something is <code>True</code>
or <code>False</code>.</p>
<p>The records created by different constructors for a custom type can contain
different values. For example a <code>User</code> custom type could have a <code>LoggedIn</code>
constructor that creates records with a name, and a <code>Guest</code> constructor which
creates records without any contained values.</p>
<pre><code class="language-gleam">type User {
  LoggedIn(name: String)  // A logged in user with a name
  Guest                   // A guest user with no details
}
</code></pre>
<pre><code class="language-gleam">let sara = LoggedIn(name: &quot;Sara&quot;)
let rick = LoggedIn(name: &quot;Rick&quot;)
let visitor = Guest
</code></pre>
<h2 id="destructuring-1"><a class="header" href="#destructuring-1">Destructuring</a></h2>
<p>When given a custom type record we can pattern match on it to determine which
record constructor matches, and to assign names to any contained values.</p>
<pre><code class="language-gleam">fn get_name(user) {
  case user {
    LoggedIn(name) -&gt; name
    Guest -&gt; &quot;Guest user&quot;
  }
}
</code></pre>
<p>Custom types can also be destructured with a <code>let</code> binding.</p>
<pre><code class="language-gleam">type Score {
  Points(Int)
}
</code></pre>
<pre><code class="language-gleam">let score = Points(50)
let Points(p) = score

p // =&gt; 50
</code></pre>
<p>During destructuring you may also use discards (<code>_</code>) or spreads (<code>..</code>).</p>
<pre><code class="language-gleam">pub type Cat {
  Cat(name: String, cuteness: Int, age: Int)
}

let cat = Cat(name: &quot;Felix&quot;, cuteness: 9001, age: 5)
</code></pre>
<p>You will need to specify all args for a pattern match, or alternatively use the
spread operator.</p>
<pre><code class="language-gleam">// All fields present
let Cat(name: name, cuteness: _, age: _) = cat
name // &quot;Felix&quot;

// Other fields ignored by spreading
let Cat(age: age, ..) = cat
age // 5
</code></pre>
<h2 id="named-accessors"><a class="header" href="#named-accessors">Named accessors</a></h2>
<p>If a custom type has only one variant and named fields they can be accessed
using <code>.field_name</code>.</p>
<p>For example using the <code>Cat</code> type defined earlier.</p>
<pre><code class="language-gleam">let cat = Cat(name: &quot;Nubi&quot;, cuteness: 2001)
cat.name // This returns &quot;Nubi&quot;
cat.cuteness // This returns 2001
</code></pre>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Custom types can be be parameterised with other types, making their contents
variable.</p>
<p>For example, this <code>Box</code> type is a simple record that holds a single value.</p>
<pre><code class="language-gleam">pub type Box(inner_type) {
  Box(inner: inner_type)
}
</code></pre>
<p>The type of the field <code>inner</code> is <code>inner_type</code>, which is a parameter of the <code>Box</code>
type. If it holds an int the box's type is <code>Box(Int)</code>, if it holds a string the
box's type is <code>Box(String)</code>.</p>
<pre><code class="language-gleam">pub fn main() {
  let a = Box(123) // type is Box(Int)
  let b = Box(&quot;G&quot;) // type is Box(String)
}
</code></pre>
<h2 id="opaque-types"><a class="header" href="#opaque-types">Opaque types</a></h2>
<p>At times it may be useful to create a type and make the constructors and
fields private so that users of this type can only use the type through
publically exported functions.</p>
<p>For example we can create a <code>Counter</code> type which holds an int which can be
incremented. We don't want the user to alter the int value other than by
incrementing it, so we can make the type opaque to prevent them from being
able to do this.</p>
<pre><code class="language-gleam">// The type is defined with the opaque keyword
pub opaque type Counter {
  Counter(value: Int)
}

pub fn new() {
  Counter(0)
}

pub fn increment(counter: Counter) {
  Counter(counter.value + 1)
}
</code></pre>
<p>Because the <code>Counter</code> type has been marked as <code>opaque</code> it is not possible for
code in other modules to construct or pattern match on counter values or
access the <code>value</code> field. Instead other modules have to manipulate the opaque
type using the exported functions from the module, in this case <code>new</code> and
<code>increment</code>.</p>
<h2 id="record-updates"><a class="header" href="#record-updates">Record updates</a></h2>
<p>Gleam provides a dedicated syntax for updating some of the fields of a custom
type record.</p>
<pre><code class="language-gleam">import gleam/option.{Option}

pub type Person {
  Person(
    name: String,
    gender: Option(String),
    shoe_size: Int,
    age: Int,
    is_happy: Bool,
  )
}

pub fn have_birthday(person) {
  // It's this person's birthday, so increment their age and
  // make them happy
  Person(..person, age: person.age + 1, is_happy: True)
}
</code></pre>
<p>As Gleam records are immutable the update syntax does not alter the fields in
place, instead it created a new record with the values of the initial record
with the new values added.</p>
<h2 id="erlang-interop-1"><a class="header" href="#erlang-interop-1">Erlang interop</a></h2>
<p>At runtime custom type records with no contained values become atoms. The
atoms are written in <code>snake_case</code> rather than <code>CamelCase</code> so <code>LoggedIn</code>
becomes <code>logged_in</code>.</p>
<p>Custom type records with contained values are Erlang records. The Gleam
compiler generates an Erlang header file with a record definition for each
constructor, for use from Erlang.</p>
<pre><code class="language-gleam">// Gleam
Guest
LoggedIn(&quot;Kim&quot;)
</code></pre>
<pre><code class="language-elxir"># Elixir
:guest
{:logged_in, &quot;Kim&quot;}
</code></pre>
<pre><code class="language-erlang">% Erlang
guest,
{logged_in, &lt;&lt;&quot;Kim&quot;&gt;&gt;}.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="resultvalue-error"><a class="header" href="#resultvalue-error"><code>Result(value, error)</code></a></h1>
<pre><code class="language-gleam">pub type Result(value, reason) {
  Ok(value)
  Error(reason)
}
</code></pre>
<p>Gleam doesn't have exceptions or <code>null</code> to represent errors in our programs,
instead we have the <code>Result</code> type. If a function call fails, wrap the returned
value in a <code>Result</code>, either <code>Ok</code> if the function was successful, or <code>Error</code>
if it failed.</p>
<pre><code class="language-gleam">pub fn lookup(name, phone_book) {
  // ... we found a phone number in the phone book for the given name here
  Ok(phone_number)
}
</code></pre>
<p>The <code>Error</code> type needs to be given a reason for the failure in order to
return, like so:</p>
<pre><code class="language-gleam">pub type MyDatabaseError {
  InvalidQuery
  NetworkTimeout
}

pub fn insert(db_row) {
  // ... something went wrong connecting to a database here
  Error(NetworkTimeout)
}
</code></pre>
<p>In cases where we don't care about the specific error enough to want to create
a custom error type, or when the cause of the error is obvious without further
detail, the <code>Nil</code> type can be used as the <code>Error</code> reason.</p>
<pre><code class="language-gleam">pub fn lookup(name, phone_book) {
  // ... That name wasn't found in the phone book
  Error(Nil)
}
</code></pre>
<p>When we have a <code>Result</code> type returned to us from a function we can pattern
match on it using <code>case</code> to determine whether we have an <code>Ok</code> result or
an <code>Error</code> result.</p>
<p>The standard library <code>gleam/result</code> module contains helpful functions for
working with the <code>Result</code> type, make good use of them!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="try"><a class="header" href="#try">Try</a></h1>
<p>In Gleam if a function can either succeed or fail then it normally will
return the <code>Result</code> type. With <code>Result</code>, a successful return value is wrapped
in an <code>Ok</code> record, and an error value is wrapped in an <code>Error</code> record.</p>
<pre><code class="language-gleam">// parse_int(String) -&gt; Result(Int, String)

parse_int(&quot;123&quot;) // -&gt; Ok(123)
parse_int(&quot;erl&quot;) // -&gt; Error(&quot;expected a number, got `erl`&quot;)
</code></pre>
<p>When a function returns a <code>Result</code> we can pattern match on it to handle success
and failure:</p>
<pre><code class="language-gleam">case parse_int(&quot;123&quot;) {
  Error(e) -&gt; io.println(&quot;That wasn't an Int&quot;)
  Ok(i) -&gt; io.println(&quot;We parsed the Int&quot;)
}
</code></pre>
<p>This is such a common pattern in Gleam that the <code>try</code> syntax exists to make it
more concise.</p>
<pre><code class="language-gleam">try int_a = parse_int(a)
try int_b = parse_int(b)
try int_c = parse_int(c)
Ok(int_a + int_b + int_c)
</code></pre>
<p>When a variable is declared using <code>try</code> Gleam checks to see whether the value
is an Error or an Ok record. If it's an Ok then the inner value is assigned to
the variable:</p>
<pre><code class="language-gleam">try x = Ok(1)
Ok(x + 1)
// -&gt; Ok(2)
</code></pre>
<p>If it's an Error then the Error is returned immediately:</p>
<pre><code class="language-gleam">try x = Error(&quot;failure&quot;)
Ok(x + 1)
// -&gt; Error(&quot;failure&quot;)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assert"><a class="header" href="#assert">Assert</a></h1>
<p>Some times we have a function that can technically fail, but in practice we
don't expect it to happen. For example our program may start by opening a
file, if we know that the file is always going to be possible to open, then we
don't want to complicate our program with handling an error that should never
happen.</p>
<p>Other times we have errors that may occur, but we don't have any way of
realistically handling them within our program. For example if we have a web
application that talks to a database when handling each HTTP request and that
database stops responding, then we have a fatal error that cannot be recovered
from. We could detect the error in our code, but what do we do then? We <em>need</em>
the database to handle the request.</p>
<p>Lastly we may think errors are possible, but we are writing a quick script or
prototype application, so we want to only spend time on the success path for
now.</p>
<p>For these situations Gleam provides <code>assert</code>, a keyword that causes the
program to crash if a pattern does not match.</p>
<pre><code class="language-gleam">assert Ok(i) = parse_int(&quot;123&quot;)
i // =&gt; 123
</code></pre>
<p>Here the <code>assert</code> keyword has been used to say &quot;this function must return an
<code>Ok</code> value&quot; and we haven't had to write any error handling. The inner value
is assigned the variable <code>i</code> and the program continues.</p>
<pre><code class="language-gleam">assert Ok(i) = parse_int(&quot;not an int&quot;)
</code></pre>
<p>In this case the <code>parse_int</code> function returns an error, so the <code>Ok(i)</code>
pattern doesn't match and so the program crashes.</p>
<h2 id="surviving-crashes"><a class="header" href="#surviving-crashes">Surviving crashes</a></h2>
<p>Being fault tolerant and surviving crashes is a key part of Erlang's error
handling strategy, and as an Erlang based language Gleam can also take
advantage of this. To find out more about Erlang fault tolerance see the
<a href="https://github.com/gleam-lang/otp">Gleam OTP project</a> and the <a href="https://learnyousomeerlang.com/supervisors">Learn You Some Erlang chapter on
supervisors</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="todo"><a class="header" href="#todo">Todo</a></h1>
<p>Gleam's <code>todo</code> keyword is used to indicate that some code is not yet finished.</p>
<p>It can be useful when designing a module, type checking functions and types
but leaving the implementation of the functions until later.</p>
<pre><code class="language-gleam">fn favourite_number() -&gt; Int {
  // The type annotations says this returns an Int, but we don't need
  // to implement it yet.
  todo
}

pub fn main() {
  favourite_number() * 2
}
</code></pre>
<p>When this code is built Gleam will type check and compile the code to ensure
it is valid, and the <code>todo</code> will be replaced with code that crashes the
program if that function is run.</p>
<p>A message can be given as a form of documentation. The message will be printed
in the error message when the <code>todo</code> code is run.</p>
<pre><code class="language-gleam">fn favourite_number() -&gt; Int {
  todo(&quot;We're going to decide which number is best tomorrow&quot;)
}
</code></pre>
<p>When the compiler finds a <code>todo</code> it will print a warning, which can be useful
to avoid accidentally forgetting to remove a <code>todo</code>.</p>
<p>The warning also includes the expected type of the expression that needs to
replace the <code>todo</code>. This can be a useful way of asking the compiler what type
is needed if you are ever unsure.</p>
<pre><code class="language-gleam">fn main() {
  my_complicated_function(
    // What type does this function take again...?
    todo
  )
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="constants"><a class="header" href="#constants">Constants</a></h1>
<p>Gleam's module constants provide a way to use a certain fixed value in
multiple places in a Gleam project.</p>
<pre><code class="language-gleam">pub const start_year = 2101
pub const end_year = 2111

pub fn is_before(year: Int) -&gt; Bool {
  year &lt; start_year
}

pub fn is_during(year: Int) -&gt; Bool {
  start_year &lt;= year &amp;&amp; year &lt;= end_year
}
</code></pre>
<p>Like all values in Gleam constants are immutable and their values cannot be
changed, so they cannot be used as global mutable state.</p>
<p>When a constant is referenced the value is inlined by the compiler, so they
can be used in case expression guards.</p>
<pre><code class="language-gleam">pub const start_year = 2101
pub const end_year = 2111

pub describe(year: Int) -&gt; String {
  case year {
    year if year &lt; start_year -&gt; &quot;Before&quot;
    year if year &gt; end_year -&gt; &quot;After&quot;
    _ -&gt; &quot;During&quot;
  }
}
</code></pre>
<h2 id="type-annotations-1"><a class="header" href="#type-annotations-1">Type annotations</a></h2>
<p>Constants can also be given type annotations. </p>
<pre><code class="language-gleam">pub const name: String = &quot;Gleam&quot;
pub const size: Int = 100
</code></pre>
<p>These annotations serve as documentation or can be used to provide a more 
specific type than the compiler would otherwise infer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="type-aliases"><a class="header" href="#type-aliases">Type aliases</a></h1>
<p>Type aliases are a way of creating a new name for an existing type. This is
useful when the name of the type may be long and awkward to type repeatedly.</p>
<p>Here we are giving the type <code>List(#(String, String))</code> the new name
<code>Headers</code>. This may be useful in a web application where we want to write
multiple functions that return headers.</p>
<pre><code class="language-gleam">pub type Headers =
  List(#(String, String))
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bit-strings"><a class="header" href="#bit-strings">Bit strings</a></h1>
<p>Gleam has a convenient syntax for working directly with binary data called a
Bit String. Bit Strings represent a sequence of 1s and 0s.</p>
<p>Bit Strings are written literally with opening brackets <code>&lt;&lt;</code>, any number of bit
string segments separated by commas, and closing brackets <code>&gt;&gt;</code>.</p>
<h2 id="bit-string-segments"><a class="header" href="#bit-string-segments">Bit String Segments</a></h2>
<p>By default a Bit String segment represents 8 bits, also known as 1 byte.</p>
<pre><code class="language-gleam">// This is the number 3 as an 8 bit value.
// Written in binary it would be 00000011
&lt;&lt;3&gt;&gt;
</code></pre>
<p>You can also specify a bit size using either short hand or long form.</p>
<pre><code class="language-gleam">// These are the exact same value as above
// Shorthand
&lt;&lt;3:8&gt;&gt;

// Long Form
&lt;&lt;3:size(8)&gt;&gt;
</code></pre>
<p>You can specify any positive integer as the bit size.</p>
<pre><code class="language-gleam">// This is not same as above, remember we're working with a series of 1s and 0s.
// This Bit String is 16 bits long: 0000000000000011
&lt;&lt;3:size(16)&gt;&gt;
</code></pre>
<p>You can have any number of segments separated by commas.</p>
<pre><code class="language-gleam">// This is True
&lt;&lt;0:4, 1:3, 1:1&gt;&gt; == &lt;&lt;3&gt;&gt;
</code></pre>
<h2 id="bit-string-segment-options"><a class="header" href="#bit-string-segment-options">Bit String Segment Options</a></h2>
<p>There are a few more options you can attach to a segment to describe its size
and bit layout.</p>
<p><code>unit()</code> lets you create a segment of repeating size. The segment will
represent <code>unit * size</code> number of bits. If you use <code>unit()</code> you must also have
a <code>size</code> option.</p>
<pre><code class="language-gleam">// This is True
&lt;&lt;3:size(4)-unit(4)&gt;&gt; == &lt;&lt;3:size(16)&gt;&gt;
</code></pre>
<p>The <code>utf8</code>, <code>utf16</code> and <code>utf32</code> options let you put a String directly into a
Bit String.</p>
<pre><code class="language-gleam">&lt;&lt;&quot;Hello Gleam üí´&quot;:utf8&gt;&gt;
</code></pre>
<p>The <code>bit_string</code> option lets you put any other Bit String into a Bit String.</p>
<pre><code class="language-gleam">let a = &lt;&lt;0:1, 1:1, 1:1&gt;&gt;
&lt;&lt;a:bit_string, 1:5&gt;&gt; == &lt;&lt;&quot;a&quot;:utf8&gt;&gt; // True
</code></pre>
<p>Here Is the full list of options and their meaning:</p>
<h3 id="options-in-values"><a class="header" href="#options-in-values">Options in Values</a></h3>
<table><thead><tr><th>Option</th><th>Meaning</th></tr></thead><tbody>
<tr><td>bit_string</td><td>a bitstring that is any bit size</td></tr>
<tr><td>float</td><td>default size of 64 bits</td></tr>
<tr><td>int</td><td>default size of 8 bits</td></tr>
<tr><td>size</td><td>the size of the segment in bits</td></tr>
<tr><td>unit</td><td>how many times to repeat the segment, must have a size</td></tr>
<tr><td>big</td><td>big endian</td></tr>
<tr><td>little</td><td>little endian</td></tr>
<tr><td>native</td><td>endianness of the processor</td></tr>
<tr><td>utf8</td><td>a string to encode as utf8 codepoints</td></tr>
<tr><td>utf16</td><td>a string to encode as utf16 codepoints</td></tr>
<tr><td>utf32</td><td>a string to encode as utf32 codepoints</td></tr>
</tbody></table>
<h3 id="options-in-patterns"><a class="header" href="#options-in-patterns">Options in Patterns</a></h3>
<table><thead><tr><th>Option</th><th>Meaning</th></tr></thead><tbody>
<tr><td>binary</td><td>a bitstring that is a multiple of 8 bits</td></tr>
<tr><td>bit_string</td><td>a bitstring that is any bit size</td></tr>
<tr><td>float</td><td>float value, size of exactly 64 bits</td></tr>
<tr><td>int</td><td>int value, default size of 8 bits</td></tr>
<tr><td>big</td><td>big endian</td></tr>
<tr><td>little</td><td>little endian</td></tr>
<tr><td>native</td><td>endianness of the processor</td></tr>
<tr><td>signed</td><td>the captured value is signed</td></tr>
<tr><td>unsigned</td><td>the captured value is unsigned</td></tr>
<tr><td>size</td><td>the size of the segment in bits</td></tr>
<tr><td>unit</td><td>how many times to repeat the segment, must have a size</td></tr>
<tr><td>utf8</td><td>an exact string to match as utf8 codepoints</td></tr>
<tr><td>utf16</td><td>an exact string to match as utf16 codepoints</td></tr>
<tr><td>utf32</td><td>an exact string to match as utf32 codepoints</td></tr>
<tr><td>utf8_codepoint</td><td>a single valid utf8 codepoint</td></tr>
<tr><td>utf16_codepoint</td><td>a single valid utf16 codepoint</td></tr>
<tr><td>utf32_codepoint</td><td>a single valid utf32 codepoint</td></tr>
</tbody></table>
<h2 id="values-vs-patterns"><a class="header" href="#values-vs-patterns">Values vs Patterns</a></h2>
<p>Bit Strings can appear on either the left or the right side of an equals sign.
On the left they are called <strong>patterns</strong>, and on the right they are called
<strong>values</strong>.</p>
<p>This is an important distinction because values and patterns have slightly
different rules.</p>
<h3 id="rules-for-patterns"><a class="header" href="#rules-for-patterns">Rules for Patterns</a></h3>
<p>You can match on a variable length segment with the <code>bit_string</code> or <code>binary</code>
options. A pattern can have at most 1 variable length segment and it must be
the last segment.</p>
<p>In a pattern the types <code>utf8</code>, <code>utf16</code>, and <code>utf32</code> must be an exact string.
They cannot be a variable. There is no way to match a variable length section
of a binary with an exact encoding.</p>
<p>You can match a single variable codepoint with <code>utf8_codepoint</code>,
<code>utf16_codepoint</code>, and <code>utf32_codepoint</code> which will match the correct number of
bytes depending on the codepoint size and data.</p>
<h2 id="further-reading"><a class="header" href="#further-reading">Further Reading</a></h2>
<p>Gleam inherits its Bit String syntax and handling from Erlang. You can find the
Erlang documentation
<a href="https://erlang.org/doc/reference_manual/expressions.html#bit_syntax">here</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-function"><a class="header" href="#external-function">External function</a></h1>
<p>Gleam is just one of many languages on the Erlang virtual machine and JavaScript
runtimes. At times we may want to use functions from these other languages in
our Gleam programs. To enable this Gleam allows the importing of <em>external
functions</em>, which may be written in any language on the same runtime.</p>
<p>External functions are typically written in a different language with a
different type system, so the compiler is unable to determine the type of the
function and instead the programmer must inform the compiler the type.</p>
<p>Gleam trusts that the type given is correct so an inaccurate type annotation
can result in unexpected behaviour and crashes at runtime. Be careful!</p>
<h2 id="erlang-external-functions"><a class="header" href="#erlang-external-functions">Erlang external functions</a></h2>
<p>The Erlang <code>rand</code> module has a function named <code>uniform</code> that takes no
arguments and returns a <code>Float</code>.</p>
<p>The Elixir module <code>IO</code> has a function named <code>inspect</code> that takes any value,
prints it, and returns the same value.</p>
<p>If we want to import these functions and use them in our program we would do
so like this:</p>
<pre><code class="language-gleam">pub external fn random_float() -&gt; Float =
  &quot;rand&quot; &quot;uniform&quot;

// Elixir modules start with `Elixir.`
pub external fn inspect(a) -&gt; a =
  &quot;Elixir.IO&quot; &quot;inspect&quot;
</code></pre>
<h2 id="javascript-external-functions"><a class="header" href="#javascript-external-functions">JavaScript external functions</a></h2>
<p>When importing a JavaScript function the path to the module is given instead of
the module name.</p>
<pre><code class="language-javascript">// In src/my-module.mjs
export function run() {
  return 0;
}
</code></pre>
<pre><code class="language-gleam">// In src/my_program.gleam
pub external fn run() -&gt; Int =
  &quot;./my-module.js&quot; &quot;run&quot;
</code></pre>
<p>Gleam uses the JavaScript import syntax, so any module imported must use the
esmodule export syntax, and if you are using the NodeJS runtime the file
extension must be <code>.mjs</code>.</p>
<h2 id="labelled-arguments-1"><a class="header" href="#labelled-arguments-1">Labelled arguments</a></h2>
<p>Like regular functions, external functions can have labelled arguments.</p>
<pre><code class="language-gleam">pub external fn any(in: List(a), satisfying: fn(a) -&gt; Bool) =
  &quot;my_external_module&quot; &quot;any&quot;
</code></pre>
<p>This function has the labelled arguments <code>in</code> and <code>satisfying</code>, and can be
called like so:</p>
<pre><code class="language-gleam">any(in: my_list, satisfying: is_even)
any(satisfying: is_even, in: my_list)
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="external-type"><a class="header" href="#external-type">External type</a></h1>
<p>In addition to importing external functions we can also import external types.
Gleam knows nothing about the runtime representation of these types and so
they cannot be pattern matched on, but they can be used with external
functions that know how to work with them.</p>
<p>Here is an example of importing a <code>Queue</code> data type and some functions from
Erlang's <code>queue</code> module to work with the new <code>Queue</code> type.</p>
<pre><code class="language-gleam">pub external type Queue(a)

pub external fn new() -&gt; Queue(a) = &quot;queue&quot; &quot;new&quot;

pub external fn length(Queue(a)) -&gt; Int = &quot;queue&quot; &quot;len&quot;

pub external fn push(Queue(a), a) -&gt; Queue(a) = &quot;queue&quot; &quot;in&quot;
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript" src="javascript/highlightjs-gleam.js"></script>
        <script type="text/javascript" src="javascript/plausible.js"></script>
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
