<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Gleam Book</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Hello, Gleam!</a></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/installing-gleam.html"><strong aria-hidden="true">2.1.</strong> Installing Gleam</a></li><li class="chapter-item expanded "><a href="getting-started/installing-erlang.html"><strong aria-hidden="true">2.2.</strong> Installing Erlang</a></li><li class="chapter-item expanded "><a href="getting-started/editor-support.html"><strong aria-hidden="true">2.3.</strong> Editor support</a></li><li class="chapter-item expanded "><a href="getting-started/creating-a-project.html"><strong aria-hidden="true">2.4.</strong> Creating a project</a></li><li class="chapter-item expanded "><a href="getting-started/example-projects.html"><strong aria-hidden="true">2.5.</strong> Example projects</a></li></ol></li><li class="chapter-item expanded "><a href="tour/index.html"><strong aria-hidden="true">3.</strong> Language tour</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="tour/comments.html"><strong aria-hidden="true">3.1.</strong> Comments</a></li><li class="chapter-item expanded "><a href="tour/strings.html"><strong aria-hidden="true">3.2.</strong> Strings</a></li><li class="chapter-item expanded "><a href="tour/bools.html"><strong aria-hidden="true">3.3.</strong> Bools</a></li><li class="chapter-item expanded "><a href="tour/ints-and-floats.html"><strong aria-hidden="true">3.4.</strong> Ints &amp; Floats</a></li><li class="chapter-item expanded "><a href="tour/let-bindings.html"><strong aria-hidden="true">3.5.</strong> Let bindings</a></li><li class="chapter-item expanded "><a href="tour/lists.html"><strong aria-hidden="true">3.6.</strong> Lists</a></li><li class="chapter-item expanded "><a href="tour/tuples.html"><strong aria-hidden="true">3.7.</strong> Tuples</a></li><li class="chapter-item expanded "><a href="tour/case-expressions.html"><strong aria-hidden="true">3.8.</strong> Case expressions</a></li><li class="chapter-item expanded "><a href="tour/functions.html"><strong aria-hidden="true">3.9.</strong> Functions</a></li><li class="chapter-item expanded "><a href="tour/modules.html"><strong aria-hidden="true">3.10.</strong> Modules</a></li><li class="chapter-item expanded "><a href="tour/custom-types.html"><strong aria-hidden="true">3.11.</strong> Custom types</a></li><li class="chapter-item expanded "><a href="tour/type-aliases.html"><strong aria-hidden="true">3.12.</strong> Type aliases</a></li><li class="chapter-item expanded "><a href="tour/external-functions.html"><strong aria-hidden="true">3.13.</strong> External functions</a></li><li class="chapter-item expanded "><a href="tour/external-types.html"><strong aria-hidden="true">3.14.</strong> External types</a></li></ol></li><li class="chapter-item expanded "><a href="faqs.html"><strong aria-hidden="true">4.</strong> FAQs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">The Gleam Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#gleam" id="gleam">Gleam</a></h1>
<p>Gleam is a statically typed functional programming language for building
scalable concurrent systems.</p>
<p>It compiles to <a href="http://www.erlang.org/">Erlang</a> and has straightforward
interop with other BEAM languages such as Erlang, Elixir and LFE.</p>
<p>It looks like this:</p>
<pre><code class="language-rust noplaypen">pub type Tree(value) {
  Leaf(value)
  Node(Tree(value), Tree(value))
}

pub fn any(tree: Tree(a), check: fn(a) -&gt; Bool) -&gt; Bool {
  case tree {
    Leaf(i) -&gt; check(i)
    Node(left, right) -&gt; any(left, check) || any(right, check)
  }
}

pub fn has_even_leaf(tree: Tree(Int)) -&gt; Bool {
  any(tree, fn(i) {
    i % 2 == 0
  })
}
</code></pre>
<p>The source code can be found at
<a href="https://github.com/gleam-lang/gleam">https://github.com/gleam-lang/gleam</a>.</p>
<p>For Gleam chat we have the IRC channel <code>#gleam-lang</code> on Freenode.</p>
<h2><a class="header" href="#principles" id="principles">Principles</a></h2>
<h3><a class="header" href="#be-safe" id="be-safe">Be safe</a></h3>
<p>An expressive type system inspired by the ML family of languages helps us find
and prevent bugs at compile time, long before it reaches your users.</p>
<p>For the problems the type system can't solve (such as your server being hit by
a bolt of lightning) the Erlang/OTP runtime provides well tested mechanisms
for gracefully handling failure.</p>
<h3><a class="header" href="#be-friendly" id="be-friendly">Be friendly</a></h3>
<p>Hunting down bugs can be stressful so feedback from the compiler should be
as clear and helpful as possible. We want to spend more time working on our
application and less time looking for typos or deciphering cryptic error
messages.</p>
<p>As a community we want to be friendly too. People of all backgrounds, genders,
and experience levels are welcome and must receive equal respect.</p>
<h3><a class="header" href="#be-performant" id="be-performant">Be performant</a></h3>
<p>The Erlang/OTP runtime is known for its speed and ability to scale, enabling
organisations such as WhatsApp and Ericsson to reliably handle massive amounts
of traffic at low latency. Gleam should take full advantage of this runtime
and be as fast as other BEAM languages such as Erlang and Elixir.</p>
<h3><a class="header" href="#be-a-good-citizen" id="be-a-good-citizen">Be a good citizen</a></h3>
<p>Gleam makes it easy to use code written in other BEAM languages such as
Erlang, Elixir and LFE, so there's a rich ecosystem of tools and library for
Gleam users to make use of.</p>
<p>Users of other BEAM languages should in return be able to take advantage of
Gleam, either by transparently making use of libraries written in Gleam, or by
adding Gleam modules to their existing project with minimal fuss.</p>
<h1><a class="header" href="#getting-started" id="getting-started">Getting started</a></h1>
<p>In this chapter we get the Gleam language set up on your computer and learn
how to create an navigate a Gleam project.</p>
<p>Good luck, have fun!</p>
<h1><a class="header" href="#installing-gleam" id="installing-gleam">Installing Gleam</a></h1>
<h2><a class="header" href="#precompiled-for-linux-windows-and-macos" id="precompiled-for-linux-windows-and-macos">Precompiled for Linux, Windows, and macOS</a></h2>
<p>The easiest way to install Gleam on Linux, Windows, and Apple macOS is to download a
prebuilt version of the compiler from the <a href="https://github.com/gleam-lang/gleam/releases">GitHub release
page</a>.</p>
<h2><a class="header" href="#mac-os-x" id="mac-os-x">Mac OS X</a></h2>
<h3><a class="header" href="#using-homebrew" id="using-homebrew">Using Homebrew</a></h3>
<p>With <a href="https://brew.sh">Homebrew</a> installed run the following:</p>
<pre><code class="language-sh">brew update
brew install gleam
</code></pre>
<h2><a class="header" href="#asdf-version-manager" id="asdf-version-manager">asdf version manager</a></h2>
<p><a href="https://github.com/asdf-vm/asdf">asdf</a> is a tool for installing and managing
multiple version of programming languages at the same time. Install the
<a href="https://github.com/vic/asdf-gleam">asdf-gleam plugin</a> to manage Gleam with
asdf.</p>
<h2><a class="header" href="#arch-linux" id="arch-linux">Arch Linux</a></h2>
<p>Gleam is available through the <a href="https://wiki.archlinux.org/index.php/Arch_User_Repository">Arch User Repository</a>
as package <code>gleam</code>. You can use your prefered <a href="https://wiki.archlinux.org/index.php/AUR_helpers">helper</a>
to install it or clone it for manual build from <a href="https://aur.archlinux.org/gleam.git">https://aur.archlinux.org/gleam.git</a>.</p>
<h2><a class="header" href="#build-from-source" id="build-from-source">Build from source</a></h2>
<p>The compiler is written in the Rust programming language and so if you wish to
build Gleam from source you will need to <a href="https://www.rust-lang.org/tools/install">install the Rust
compiler</a>.</p>
<pre><code class="language-sh"># Download the Gleam source code git repository
cd /tmp
git clone https://github.com/gleam-lang/gleam.git --branch v0.5.0
cd gleam

# Build the Gleam compiler. This will take some time!
make install

# Verify the compiler is installed
# Prints &quot;gleam $VERSION&quot;
gleam --version
</code></pre>
<h1><a class="header" href="#installing-erlang" id="installing-erlang">Installing Erlang</a></h1>
<p>Gleam compiles to Erlang code, so Erlang needs to be installed to run Gleam
code.</p>
<p>Precompiled builds for many popular operating systems can be downloaded from
the <a href="https://www.erlang-solutions.com/resources/download.html">Erlang solutions website</a>,</p>
<p>Guides for installing Erlang on specific operating systems can be found below,
as well as information on installing multiple versions of Erlang at once using
version manager tools.</p>
<p>Once Erlang has been installed you can check it is working by typing <code>erl -version</code> in your computer's terminal. You will see version information like
this if all is well:</p>
<pre><code>$ erl -version
Erlang (SMP,ASYNC_THREADS,HIPE) (BEAM) emulator version 10.1
</code></pre>
<h3><a class="header" href="#linux" id="linux">Linux</a></h3>
<h4><a class="header" href="#debian-linux" id="debian-linux">Debian Linux</a></h4>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<h4><a class="header" href="#ubuntu-linux" id="ubuntu-linux">Ubuntu Linux</a></h4>
<pre><code class="language-sh">sudo apt-get update
sudo apt-get install erlang
</code></pre>
<h3><a class="header" href="#mac-os-x-1" id="mac-os-x-1">Mac OS X</a></h3>
<h4><a class="header" href="#using-homebrew-1" id="using-homebrew-1">Using Homebrew</a></h4>
<p>With <a href="https://brew.sh">Homebrew</a> installed run the following:</p>
<pre><code class="language-sh">brew update
brew install erlang
</code></pre>
<h3><a class="header" href="#windows" id="windows">Windows</a></h3>
<h4><a class="header" href="#using-chocolatey" id="using-chocolatey">Using Chocolatey</a></h4>
<p>With <a href="https://chocolatey.org/">Chocolatey</a> installed on your computer run the
following:</p>
<pre><code>choco install erlang
</code></pre>
<h3><a class="header" href="#using-version-managers" id="using-version-managers">Using version managers</a></h3>
<h4><a class="header" href="#asdf" id="asdf">asdf</a></h4>
<p>The asdf version manager has a plugin for installing Erlang. Installation and
usage instructions can be found here:</p>
<ul>
<li><a href="https://github.com/asdf-vm/asdf">https://github.com/asdf-vm/asdf</a></li>
<li><a href="https://github.com/asdf-vm/asdf-erlang">https://github.com/asdf-vm/asdf-erlang</a></li>
</ul>
<h1><a class="header" href="#editor-support" id="editor-support">Editor support</a></h1>
<p>Gleam plugins are available for several popular editors. If one exists for
your editor of choice consider installing it for syntax highlighting and other
niceties.</p>
<ul>
<li><strong>Vim</strong> - <a href="https://github.com/gleam-lang/gleam.vim">https://github.com/gleam-lang/gleam.vim</a></li>
<li><strong>Emacs</strong> - <a href="https://github.com/gleam-lang/gleam-mode">https://github.com/gleam-lang/gleam-mode</a></li>
<li><strong>Visual Studio Code</strong> - <a href="https://github.com/rawburt/vscode-gleam-syntax">https://github.com/rawburt/vscode-gleam-syntax</a></li>
</ul>
<h1><a class="header" href="#creating-a-project" id="creating-a-project">Creating a project</a></h1>
<h2><a class="header" href="#installing-the-rebar3-build-tool" id="installing-the-rebar3-build-tool">Installing the rebar3 build tool</a></h2>
<p><strong>Note</strong>: Gleam's tooling is very young and in a state of flux. Expect rough
edges and breaking changes to come.</p>
<p>The Gleam compiler can build Gleam projects that are managed with the standard
Erlang build tool, rebar3. If you don't have rebar3 installed please <a href="https://www.rebar3.org/">install
it now</a>.</p>
<h2><a class="header" href="#generating-a-project" id="generating-a-project">Generating a project</a></h2>
<p>Now a project can be generated like so:</p>
<pre><code class="language-sh">gleam new my_fantastic_library --description &quot;Getting started with Gleam!&quot;
cd my_fantastic_library
</code></pre>
<p>You'll now have a project with this structure:</p>
<pre><code>.
├── gleam.toml
├── LICENSE
├── README.md
├── rebar.config
├── src
│   ├── my_fantastic_library.app.src
│   └── my_fantastic_library.gleam
└── test
    └── my_fantastic_library_test.gleam

2 directories, 7 files
</code></pre>
<p>The project is managed and built using rebar3, the standard Erlang build tool.
Here are some commonly used commands rebar3 commands that you can use with
your new project:</p>
<pre><code class="language-sh"># Run an interactive shell with your code loaded (Erlang syntax)
rebar3 shell

# Run the eunit tests
rebar3 eunit
</code></pre>
<p>More information can be found on the <a href="https://www.rebar3.org/docs">rebar3 documentation website</a>.</p>
<h2><a class="header" href="#applications" id="applications">Applications</a></h2>
<p>The default project generated is a library, but we may want to create an
application instead. If we specify an alternate template when creating a
project we can instead generate an application project compatible with the
Erlang OTP framework.</p>
<pre><code class="language-sh">gleam new my_fantastic_application --template app
</code></pre>
<h2><a class="header" href="#what-next" id="what-next">What next?</a></h2>
<p>Want to see some Gleam code? See the <a href="getting-started/./example-projects.html">example projects</a>.</p>
<p>Looking to learn the language? Check out the <a href="getting-started/../tour">language tour</a>.</p>
<p>Need ideas for a project? We have a <a href="https://github.com/gleam-lang/suggestions/issues?q=is%3Aopen+is%3Aissue+label%3Aarea%3Alibraries">list of libraries</a> that need
writing.</p>
<h1><a class="header" href="#example-projects" id="example-projects">Example projects</a></h1>
<p>When learning a new language it can often be used to have example code to
refer to and learn from, so here's some examples:</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomgleam-langexample-url-shortenertiny-url-shortenera" id="a-hrefhttpsgithubcomgleam-langexample-url-shortenertiny-url-shortenera"><a href="https://github.com/gleam-lang/example-url-shortener">Tiny: URL shortener</a></a></h2>
<p>A simple HTML serving web application that takes URLs and gives the user a
shorter URL to use in its place.</p>
<p>Uses the Elli web server and the Postgresql database via the epgsql client.</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomgleam-langstdlibthe-gleam-standard-librarya" id="a-hrefhttpsgithubcomgleam-langstdlibthe-gleam-standard-librarya"><a href="https://github.com/gleam-lang/stdlib">The Gleam standard library</a></a></h2>
<p>A collection of modules for working with the common data structures of Gleam.</p>
<h2><a class="header" href="#a-hrefhttpsgithubcomgleam-experimentsgleam-experimentsa" id="a-hrefhttpsgithubcomgleam-experimentsgleam-experimentsa"><a href="https://github.com/gleam-experiments">Gleam Experiments</a></a></h2>
<p>The Gleam Experiments GitHub organisation is home to many useful libraries
for use in Gleam projects such as OTP bindings, database clients, and lazy
data structures.</p>
<h1><a class="header" href="#language-tour" id="language-tour">Language Tour</a></h1>
<p>In this chapter we explore the fundamentals of the Gleam language, namely its
syntax, core data structures, flow control features, and static type system.</p>
<p>After completion the reader should know enough to start reading and writing
Gleam code, assuming they have some prior programming experience.</p>
<p>In some sections we touch on the runtime representation of various features.
This is useful for programmers with Erlang or Elixir experience who wish to
use Gleam alongside these languages. If you are using Gleam alone this
information can be safely ignored.</p>
<h1><a class="header" href="#comments" id="comments">Comments</a></h1>
<p>Gleam allows you to write comments in your code.</p>
<p>Here’s a simple comment:</p>
<pre><code class="language-rust noplaypen">// Hello, world!
</code></pre>
<p>In Gleam, comments must start with two slashes and continue until the end of the
line. For comments that extend beyond a single line, you’ll need to include
<code>//</code> on each line, like this:</p>
<pre><code class="language-rust noplaypen">// Hello, world! I have a lot to say, so much that it will take multiple
// lines of text. Therefore, I will start each line with // to denote it
// as part of a multi-line comment.
</code></pre>
<p>Comments can also be placed at the end of lines containing code:</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y // here we are adding two values together
}
</code></pre>
<p>Comments may also be indented:</p>
<pre><code class="language-rust noplaypen">
pub fn multiply(x, y) {
  // here we are multiplying x by y
  x * y 
}
</code></pre>
<h1><a class="header" href="#string" id="string">String</a></h1>
<p>Gleam's has UTF-8 binary strings, written as text surrounded by double quotes.</p>
<pre><code class="language-rust noplaypen">&quot;Hello, Gleam!&quot;
</code></pre>
<p>Strings can span multiple lines.</p>
<pre><code class="language-rust noplaypen">&quot;Hello
Gleam!&quot;
</code></pre>
<p>Special characters such as <code>&quot;</code> need to be escaped with a <code>\</code> character.</p>
<pre><code class="language-rust noplaypen">&quot;Here is a double quote -&gt; \&quot; &lt;-&quot;
</code></pre>
<h1><a class="header" href="#bool" id="bool">Bool</a></h1>
<p>A Bool can be either <code>True</code> or <code>False</code>.</p>
<p>Gleam defines a handful of operators that work with Bools.</p>
<pre><code class="language-rust noplaypen">False &amp;&amp; False // =&gt; False
False &amp;&amp; True  // =&gt; False
True &amp;&amp; False  // =&gt; False
True &amp;&amp; True   // =&gt; True

False || False // =&gt; False
False || True  // =&gt; True
True || False  // =&gt; True
True || True   // =&gt; True
</code></pre>
<p><code>&amp;&amp;</code> and <code>||</code> are <em>short circuiting</em>, meaning they don't evaluate the right
hand side if they don't have to.</p>
<p><code>&amp;&amp;</code> evaluates the right hand side if the left hand side is <code>True</code>.</p>
<p><code>||</code> evaluates the right hand side if the left hand side is <code>False</code>.</p>
<h2><a class="header" href="#erlang-interop" id="erlang-interop">Erlang interop</a></h2>
<p>While written in the code using a capital letter, they are represented at
runtime with the atoms <code>true</code> and <code>false</code>, making them compatible with Elixir
and Erlang's booleans.</p>
<p>This is important if you want to use Gleam and Elixir or Erlang together in
one project.</p>
<pre><code class="language-rust noplaypen">// Gleam
True
False
</code></pre>
<pre><code class="language-erlang">% Erlang
true.
false.
</code></pre>
<h1><a class="header" href="#int-and-float" id="int-and-float">Int and Float</a></h1>
<p>Gleam's main number types are Int and Float.</p>
<h2><a class="header" href="#ints" id="ints">Ints</a></h2>
<p>Ints are &quot;whole&quot; numbers.</p>
<pre><code class="language-rust noplaypen">1
2
-3
4001
</code></pre>
<p>Gleam has several operators that work with Ints.</p>
<pre><code class="language-rust noplaypen">1 + 1 // =&gt; 2
5 - 1 // =&gt; 4
5 / 2 // =&gt; 2
3 * 3 // =&gt; 9
5 % 2 // =&gt; 1

2 &gt; 1  // =&gt; True
2 &lt; 1  // =&gt; False
2 &gt;= 1 // =&gt; True
2 &lt;= 1 // =&gt; False
</code></pre>
<h2><a class="header" href="#floats" id="floats">Floats</a></h2>
<p>Floats are numbers that have a decimal point.</p>
<pre><code class="language-rust noplaypen">1.5
2.0
-0.1
</code></pre>
<p>Floats also have their own set of operators.</p>
<pre><code class="language-rust noplaypen">1.0 +. 1.4 // =&gt; 2.4
5.0 -. 1.5 // =&gt; 3.5
5.0 /. 2.0 // =&gt; 2.5
3.0 *. 3.1 // =&gt; 9.3

2.0 &gt;. 1.0  // =&gt; True
2.0 &lt;. 1.0  // =&gt; False
2.0 &gt;=. 1.0 // =&gt; True
2.0 &lt;=. 1.0 // =&gt; False
</code></pre>
<h1><a class="header" href="#let-bindings" id="let-bindings">Let bindings</a></h1>
<p>A value can be given a name using <code>let</code>. Names can be reused by later let
bindings, but the values contained are <em>immutable</em>, meaning the values
themselves cannot be changed.</p>
<pre><code class="language-rust noplaypen">let x = 1
let y = x
let x = 2

x  // =&gt; 2
y  // =&gt; 1
</code></pre>
<h1><a class="header" href="#list" id="list">List</a></h1>
<p>Lists are ordered collections of values. They're one of the most common data
structures in Gleam.</p>
<p>Lists are <em>homogeneous</em>, meaning all the elements of a List must be of the
same type. Attempting to construct a list of multiple types of element will
result in the compiler presenting a type error.</p>
<pre><code class="language-rust noplaypen">[1, 2, 3, 4]  // List(Int)
[1.22, 2.30]  // List(Float)
[1.22, 3, 4]  // Type error!
</code></pre>
<p>Prepending to a list is very fast, and is the preferred way to add new values.</p>
<pre><code class="language-rust noplaypen">[1 | [2, 3]]  // =&gt; [1, 2, 3]
</code></pre>
<p>Note that as all data structures in Gleam are immutable so prepending to a
list does not change the original list, instead it efficiently creates a new
list with the new additional element.</p>
<pre><code class="language-rust noplaypen">let x = [2, 3]
let y = [1 | x]


x  // =&gt; [2, 3]
y  // =&gt; [1, 2, 3]
</code></pre>
<h1><a class="header" href="#tuple" id="tuple">Tuple</a></h1>
<p>Lists are good for when we want a collection of one type, but sometime we want
to combine multiple values of different types. In this case tuples are a quick
and convenient option.</p>
<pre><code class="language-rust noplaypen">fn run() {
  tuple(10, &quot;hello&quot;) // Type is tuple(Int, String)
  tuple(1, 4.2, [0]) // Type is tuple(Int, Float, List(Int))
}
</code></pre>
<h1><a class="header" href="#case" id="case">Case</a></h1>
<p>The <code>case</code> expression is the most common kind of flow control in Gleam code. It
allows us to say &quot;if the data has this shape then do that&quot;, which we call
<em>pattern matching</em>.</p>
<p>Here we match on an <code>Int</code> and return a specific string for the values 0, 1,
and 2. The final pattern <code>n</code> matches any other value that did not match any of
the previous patterns.</p>
<pre><code class="language-rust noplaypen">case some_number {
  0 -&gt; &quot;Zero&quot;
  1 -&gt; &quot;One&quot;
  2 -&gt; &quot;Two&quot;
  n -&gt; &quot;Some other number&quot; // This matches anything
}
</code></pre>
<p>Pattern matching on a <code>Bool</code> value is the Gleam alternative to the <code>if else</code>
statement found in other languages.</p>
<pre><code class="language-rust noplaypen">case some_bool {
  True -&gt; &quot;It's true!&quot;
  False -&gt; &quot;It's not true.&quot;
}
</code></pre>
<p>Gleam's <code>case</code> is an expression, meaning it returns a value and can be used
anywhere we would use a value. For example, we can name the value of a case
expression with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">let description =
  case True {
    True -&gt; &quot;It's true!&quot;
    False -&gt; &quot;It's not true.&quot;
  }

description  // =&gt; &quot;It's true!&quot;
</code></pre>
<h2><a class="header" href="#destructuring" id="destructuring">Destructuring</a></h2>
<p>A <code>case</code> expression can be used to destructure values that
contain other values, such as tuples and lists.</p>
<pre><code class="language-rust noplaypen">case xs {
  [] -&gt; &quot;This list is empty&quot;
  [a] -&gt; &quot;This list has 1 element&quot;
  [a, b] -&gt; &quot;This list has 2 elements&quot;
  _other -&gt; &quot;This list has more than 2 elements&quot;
}
</code></pre>
<p>It's not just the top level data structure that can be pattern matches,
contained values can also be matched. This gives <code>case</code> the ability to
concisely express flow control that might be verbose without pattern matching.</p>
<pre><code class="language-rust noplaypen">case xs {
  [[]] -&gt; &quot;The only element is an empty list&quot;
  [[] | _] -&gt; &quot;The 1st element is an empty list&quot;
  [[4] | _] -&gt; &quot;The 1st element is a list of the number 4&quot;
  other -&gt; &quot;Something else&quot;
}
</code></pre>
<p>Pattern matching also works in <code>let</code> bindings, though patterns that do not
match all instances of that type may result in a runtime error.</p>
<pre><code class="language-rust noplaypen">let [a] = [1]    // a is 1
let [b] = [1, 2] // Runtime error! The pattern has 1 element but the value has 2
</code></pre>
<h2><a class="header" href="#matching-on-multiple-values" id="matching-on-multiple-values">Matching on multiple values</a></h2>
<p>Sometimes it is useful to pattern match on multiple values at the same time,
so <code>case</code> supports having multiple subjects.</p>
<pre><code class="language-rust noplaypen">case x, y {
  1, 1 -&gt; &quot;both are 1&quot;
  1, _ -&gt; &quot;x is 1&quot;
  _, 1 -&gt; &quot;y is 1&quot;
  _, _ -&gt; &quot;neither is 1&quot;
}
</code></pre>
<h2><a class="header" href="#assigning-names-to-sub-patterns" id="assigning-names-to-sub-patterns">Assigning names to sub-patterns</a></h2>
<p>Sometimes when pattern matching we want to assign a name to a value while
specifying it's shape at the same time. We can do this using the <code>as</code> keyword.</p>
<pre><code class="language-rust noplaypen">case xs {
  [[_ | _] as inner_list] -&gt; inner_list
  other -&gt; []
}
</code></pre>
<h2><a class="header" href="#checking-equality-and-ordering-in-patterns" id="checking-equality-and-ordering-in-patterns">Checking equality and ordering in patterns</a></h2>
<p>The <code>if</code> keyword can be used to add a guard expression to a case clause. Both the patterns have to match and the guard has to evaluate to <code>True</code> for the clause to match. The guard expression can check for equality or ordering for <code>Int</code> and <code>Float</code>.</p>
<pre><code class="language-rust noplaypen">case xs {
  [a, b, c] if a == b &amp;&amp; b != c -&gt; &quot;ok&quot;
  _other -&gt; &quot;ko&quot;
}
</code></pre>
<pre><code class="language-rust noplaypen">case xs {
  [a, b, c] if a &gt;. b &amp;&amp; a &lt;=. c -&gt; &quot;ok&quot;
  _other -&gt; &quot;ko&quot;
}
</code></pre>
<h2><a class="header" href="#alternative-clause-patterns" id="alternative-clause-patterns">Alternative clause patterns</a></h2>
<p>Alternative patterns can be given for a case clause using the <code>|</code> operator. If
any of the patterns match then the clause matches.</p>
<p>Here the first clause will match if the variable <code>number</code> holds 2, 4, 6 or 8.</p>
<pre><code class="language-rust noplaypen">case number {
  2 | 4 | 6 | 8 -&gt; &quot;This is an even number&quot;
  1 | 3 | 5 | 7 -&gt; &quot;This is an odd number&quot;
  _ -&gt; &quot;I'm not sure&quot;
}
</code></pre>
<p>If the patterns declare variables then the same variables must be declared in
all patterns, and the variables must have the same type in all the patterns.</p>
<pre><code class="language-rust noplaypen">case list {
  [1, x] | x -&gt; x // Error! Int != List(Int)
  _ -&gt; 0
}
</code></pre>
<h1><a class="header" href="#function" id="function">Function</a></h1>
<h2><a class="header" href="#named-functions" id="named-functions">Named functions</a></h2>
<p>Named functions in Gleam are defined using the <code>pub fn</code> keywords.</p>
<pre><code class="language-rust noplaypen">pub fn add(x: Int, y: Int) -&gt; Int {
  x + y
}

pub fn multiply(x: Int, y: Int) -&gt; Int {
  x * y
}
</code></pre>
<p>Functions in Gleam are first class values and so can be assigned to variables,
passed to functions, or anything else you might do with any other data type.</p>
<pre><code class="language-rust noplaypen">// This function takes a function as an argument
pub fn twice(f: fn(t) -&gt; t, x: t) -&gt; t {
  f(f(x))
}

pub fn add_one(x: Int) -&gt; Int {
  x + 1
}

pub fn add_two(x: Int) -&gt; Int {
  twice(add_one, x)
}
</code></pre>
<h2><a class="header" href="#pipe-operator" id="pipe-operator">Pipe Operator</a></h2>
<p>Gleam provides syntax for passing the result of one function to the arguments of another function, the pipe operator (<code>|&gt;</code>). This is similar in functionality to the same operator in Elixir or F#.</p>
<p>The pipe operator allows you to chain function calls without using a plethora of parenthesis. For a simple example, consider the following implementation of <code>string.reverse</code> in Gleam:</p>
<pre><code class="language-rust noplaypen">iodata.to_string(iodata.reverse(iodata.new(string)))
</code></pre>
<p>This can be expressed more naturally using the pipe operator, eliminating the need to track parenthesis closure.</p>
<pre><code class="language-rust noplaypen">string
|&gt; iodata.new
|&gt; iodata.reverse
|&gt; iodata.to_string
</code></pre>
<p>Each line of this expression applies the function to the result of the previous line. This works easily because each of these functions take only one argument. Syntax is available to substitute specific arguments of functions that take more than one argument; for more, look below in the section &quot;Function capturing&quot;.</p>
<h2><a class="header" href="#type-annotations" id="type-annotations">Type annotations</a></h2>
<p>Function arguments are normally annotated with their type, and the
compiler will check these annotations and ensure they are correct.</p>
<pre><code class="language-rust noplaypen">fn identity(x: some_type) -&gt; some_type {
  x
}

fn inferred_identity(x) {
  x
}
</code></pre>
<p>The Gleam compiler can infer all the types of Gleam code without annotations
and both annotated and unannotated code is equally safe. It's considered a
best practice to always write type annotations for your functions as they
provide useful documentation, and they encourage thinking about types as code
is being written.</p>
<h2><a class="header" href="#labelled-arguments" id="labelled-arguments">Labelled arguments</a></h2>
<p>When functions take several arguments it can be difficult for the user to
remember what the arguments are, and what order they are expected in.</p>
<p>To help with this Gleam supports <em>labelled arguments</em>, where function
arguments are given an external label in addition to their internal name.</p>
<p>Take this function that replaces sections of a string:</p>
<pre><code class="language-rust noplaypen">pub fn replace(string: String, pattern: String, replacement: String) {
  // ...
}
</code></pre>
<p>It can be given labels like so.</p>
<pre><code class="language-rust noplaypen">pub fn replace(
  in string: String,
  each pattern: String,
  with replacement: String,
) {
  // The variables `string`, `pattern`, and `replacement` are in scope here
}
</code></pre>
<p>These labels can then be used when calling the function.</p>
<pre><code class="language-rust noplaypen">replace(in: &quot;A,B,C&quot;, each: &quot;,&quot;, with: &quot; &quot;)

// Labelled arguments can be given in any order
replace(each: &quot;,&quot;, with: &quot; &quot;, in: &quot;A,B,C&quot;)

// Arguments can still be given in a positional fashion
replace(&quot;A,B,C&quot;, &quot;,&quot;, &quot; &quot;)
</code></pre>
<p>The use of argument labels can allow a function to be called in an expressive,
sentence-like manner, while still providing a function body that is readable
and clear in intent.</p>
<h2><a class="header" href="#anonymous-functions" id="anonymous-functions">Anonymous functions</a></h2>
<p>Anonymous functions can be defined with a similar syntax.</p>
<pre><code class="language-rust noplaypen">pub fn run() {
  let add = fn(x, y) { x + y }

  add(1, 2)
}
</code></pre>
<h2><a class="header" href="#function-capturing" id="function-capturing">Function capturing</a></h2>
<p>There is a shorthand syntax for creating anonymous functions that take one
argument and call another function. The <code>_</code> is used to indicate where the
argument should be passed.</p>
<pre><code class="language-rust noplaypen">pub fn add(x, y) {
  x + y
}

pub fn run() {
  let add_one = add(1, _)

  add_one(2)
}
</code></pre>
<p>The function capture syntax is often used with the pipe operator to create
a series of transformations on some data.</p>
<pre><code class="language-rust noplaypen">pub fn add(x: Int , y: Int ) -&gt; Int {
  x + y
}

pub fn run() {
  // This is the same as add(add(add(1, 3), 6), 9)
  1
  |&gt; add(_, 3)
  |&gt; add(_, 6)
  |&gt; add(_, 9)
}
</code></pre>
<h1><a class="header" href="#module" id="module">Module</a></h1>
<p>Gleam programs are made up of bundles of functions and types called modules.
Each module has its own namespace and can export types and values to be used
by other modules in the program.</p>
<pre><code class="language-rust noplaypen">// inside src/nasa/rocket_ship.gleam

fn count_down() {
  &quot;3... 2... 1...&quot;
}

fn blast_off() {
  &quot;BOOM!&quot;
}

pub fn launch() {
  [
    count_down(),
    blast_off(),
  ]
}
</code></pre>
<p>Here we can see a module named <code>nasa/rocket_ship</code>, the name determined by the
filename <code>src/nasa/rocket_ship.gleam</code>. Typically all the modules for one
project would live within a directory with the name of the project, such as
<code>nasa</code> in this example.</p>
<p>For the functions <code>count_down</code> and <code>blast_off</code> we have omitted the <code>pub</code>
keyword, so these functions are <em>private</em> module functions. They can only be
called by other functions within the same module.</p>
<h2><a class="header" href="#import" id="import">Import</a></h2>
<p>To use functions or types from another module we need to import them using the
<code>import</code> keyword.</p>
<pre><code class="language-rust noplaypen">// inside src/nasa/moon_base.gleam

import nasa/rocket_ship

pub fn explore_space() {
  rocket_ship.launch()
}
</code></pre>
<p>The statement <code>import nasa/rocket_ship</code> creates a new variable with the name
<code>rocket_ship</code> and the value of the <code>rocket_ship</code> module.</p>
<p>In the <code>explore_space</code> function we call the imported module's public <code>launch</code>
function using the <code>.</code> operator.
If we had attempted to call <code>count_down</code> it would result in a compile time
error as this function is private in the <code>rocket_ship</code> module.</p>
<h2><a class="header" href="#named-import" id="named-import">Named import</a></h2>
<p>It is also possible to give a module a custom name when importing it using the
<code>as</code> keyword.</p>
<pre><code class="language-rust noplaypen">import unix/cat
import animal/cat as kitty
</code></pre>
<p>This may be useful to differentiate between multiple modules that would have
the same default name when imported.</p>
<h2><a class="header" href="#unqualified-import" id="unqualified-import">Unqualified import</a></h2>
<p>Values and types can also be imported in an unqualified fashion.</p>
<pre><code class="language-rust noplaypen">import animal/cat.{Cat, stroke}

pub fn main() {
  let kitty = Cat(name: &quot;Nubi&quot;)
  stroke(kitty)
}
</code></pre>
<p>This may be useful for values that are used frequently in a module, but
generally qualified imports are preferred as it makes it clearer where the
value is defined.</p>
<h1><a class="header" href="#custom-types" id="custom-types">Custom types</a></h1>
<p>Gleam's custom types are named collections of keys and values. They are
similar to objects in object oriented languages, though they don't have
methods.</p>
<p>Custom types are defined with the <code>type</code> keyword.</p>
<pre><code class="language-rust noplaypen">pub type Cat {
  Cat(name: String, cuteness: Int)
}
</code></pre>
<p>Here we have defined a custom type called <code>Cat</code>. It's constructor is called
<code>Cat</code> and it takes has two fields: A <code>name</code> field which is a <code>String</code>, and a
<code>cuteness</code> field which is an <code>Int</code>.</p>
<p>The <code>pub</code> keyword has been used to make this type usable from other modules.</p>
<p>Once defined the custom type can be used in functions:</p>
<pre><code class="language-rust noplaypen">fn cats() {
  // Labelled fields can be given in any order
  let cat1 = Cat(name: &quot;Nubi&quot;, cuteness: 2001)
  let cat2 = Cat(cuteness: 1805, name: &quot;Biffy&quot;)

  // Alternatively fields can be given without labels
  let cat3 = Cat(&quot;Ginny&quot;, 1950)

  [cat1, cat2, cat3]
}
</code></pre>
<h2><a class="header" href="#multiple-constructors" id="multiple-constructors">Multiple constructors</a></h2>
<p>Custom types in Gleam can be defined with multiple constructors, making them a
way of modeling data that can be one of a few different variants.</p>
<p>We've seen a custom type with multiple constructors already in this chapter-
<code>Bool</code>.</p>
<p>Bool is defined like this:</p>
<pre><code class="language-rust noplaypen">// A Bool is a value that is either `True` or `False`
pub type Bool {
  True
  False
}
</code></pre>
<p>The records created by different constructors for a custom type can contain
different values. For example a User custom type could have a LoggedIn
constructors that creates records with a name, and a Guest constructor which
creates records without any contained values.</p>
<pre><code class="language-rust noplaypen">type User {
  LoggedIn(name: String)  // A logged in user with a name
  Guest                   // A guest user with no details
}
</code></pre>
<pre><code class="language-rust noplaypen">let sara = LoggedIn(name: &quot;Sara&quot;)
let rick = LoggedIn(name: &quot;Rick&quot;)
let visitor = Guest
</code></pre>
<h2><a class="header" href="#destructuring-1" id="destructuring-1">Destructuring</a></h2>
<p>When given a custom type record we can pattern match on it to determine which
record constructor matches, and to assign names to any contained values.</p>
<pre><code class="language-rust noplaypen">fn get_name(user) {
  case user {
    LoggedIn(name) -&gt; name
    Guest -&gt; &quot;Guest user&quot;
  }
}
</code></pre>
<p>Custom types can also be destructured with a <code>let</code> binding.</p>
<pre><code class="language-rust noplaypen">type Score {
  Points(Int)
}
</code></pre>
<pre><code class="language-rust noplaypen">let score = Points(50)
let Points(p) = score

p // =&gt; 50
</code></pre>
<h2><a class="header" href="#commonly-used-custom-types" id="commonly-used-custom-types">Commonly used custom types</a></h2>
<h3><a class="header" href="#bool-1" id="bool-1"><code>Bool</code></a></h3>
<pre><code class="language-rust noplaypen">pub type Bool {
  True
  False
}
</code></pre>
<p>As seen above Gleam's <code>Bool</code> type is a custom type! Use it to answer yes/no
questions and to indicate whether something is <code>True</code> or <code>False</code>.</p>
<h3><a class="header" href="#resultvalue-error" id="resultvalue-error"><code>Result(value, error)</code></a></h3>
<pre><code class="language-rust noplaypen">pub type Result(value, reason) {
  Ok(value)
  Error(reason)
}
</code></pre>
<p>Gleam doesn't have exceptions of <code>null</code> to represent errors in our programs,
instead we have the <code>Result</code> type. If a function call fail wrap the returned
value in a <code>Result</code>, either <code>Ok</code> if the function was successful, or <code>Error</code>
if it failed.</p>
<pre><code class="language-rust noplaypen">pub fn lookup(name, phone_book) {
  // ... we found a phone number in the phone book for the given name here
  Ok(phone_number)
}
</code></pre>
<p>The <code>Error</code> type needs to be given a reason for the failure in order to
return, like so:</p>
<pre><code class="language-rust noplaypen">pub type MyDatabaseError {
  InvalidQuery
  NetworkTimeout
}

pub fn insert(db_row) {
  // ... something went wrong connecting to a database here
  Error(NetworkTimeout)
}
</code></pre>
<p>In cases where we don't care about the specific error enough to want to create
a custom error type, or when the cause of the error is obvious without further
detail, the <code>Nil</code> type can be used as the <code>Error</code> reason.</p>
<pre><code class="language-rust noplaypen">pub fn lookup(name, phone_book) {
  // ... That name wasn't found in the phone book
  Error(Nil)
}
</code></pre>
<p>When we have a <code>Result</code> type returned to us from a function we can pattern
match on it using <code>case</code> to determine whether we have an <code>Ok</code> result or
an <code>Error</code> result.</p>
<p>The standard library <code>gleam/result</code> module contains helpful functions for
working with the <code>Result</code> type, make good use of them!</p>
<h2><a class="header" href="#erlang-interop-1" id="erlang-interop-1">Erlang interop</a></h2>
<p>At runtime custom type records with no contained values become atoms. The
atoms are written in <code>snake_case</code> rather than <code>CamelCase</code> so <code>LoggedIn</code>
becomes <code>logged_in</code>.</p>
<p>Custom type records with contained values are Erlang records. The Gleam
compiler generates an Erlang header file with a record definition for each
constructor, for use from Erlang.</p>
<pre><code class="language-rust noplaypen">// Gleam
Guest
LoggedIn(&quot;Kim&quot;)
</code></pre>
<pre><code># Elixir
:guest
{:logged_in, &quot;Kim&quot;}
</code></pre>
<pre><code>% Erlang
guest,
{logged_in, &lt;&lt;&quot;Kim&quot;&gt;&gt;}.
</code></pre>
<h1><a class="header" href="#type-aliases" id="type-aliases">Type aliases</a></h1>
<p>Type aliases are a way of creating a new name for an existing type. This is
useful when the name of the type may be long and awkward to type repeatedly.</p>
<p>Here we are giving the type <code>List(tuple(String, String))</code> the new name
<code>Headers</code>. This may be useful in a web application where we want to write
multiple functions that return headers.</p>
<pre><code class="language-rust noplaypen">pub type Headers =
  List(tuple(String, String))
</code></pre>
<h2><a class="header" href="#commonly-used-type-aliases" id="commonly-used-type-aliases">Commonly used type aliases</a></h2>
<h3><a class="header" href="#optionvalue" id="optionvalue"><code>Option(value)</code></a></h3>
<p>The <code>gleam/result</code> module in the standard library defines <code>Option(value)</code> as
an alias for <code>Result(value, Nil)</code>.</p>
<p>This alias is useful for when you wish to return a value that may or may not
be present. This is a type safe alterntaive to a value that may be <code>null</code> in
other languages.</p>
<pre><code class="language-rust noplaypen">import gleam/result.{Option}

pub fn present() -&gt; Option(Int) {
  Ok(1) // This Int is present
}

fn not_present() -&gt; Option(Int) {
  Error(Nil) // This Int is not present
}

fn also_not_present() -&gt; Option(Int) {
  result.none() // Error(Nil) can also be written like this
}
</code></pre>
<h1><a class="header" href="#external-function" id="external-function">External function</a></h1>
<p>Gleam is just one of many languages on the Erlang virtual machine and at times
we may want to use functions from these other languages in our Gleam programs.
To enable this Gleam allows the importing of <em>external functions</em>, which may
be written in any BEAM language.</p>
<p>External functions are typically written in a different language with a
different type system, so the compiler is unable to determine the type of the
function and instead the programmer must inform the compiler the type.</p>
<p>Gleam trusts that the type given is correct so an inaccurate type annotation
can result in unexpected behaviour and crashes at runtime. Be careful!</p>
<h2><a class="header" href="#example" id="example">Example</a></h2>
<p>The Erlang <code>rand</code> module has a function named <code>uniform</code> that takes no
arguments and returns a <code>Float</code>.</p>
<p>The Elixir module <code>IO</code> has a function named <code>inspect</code> that takes any value,
prints it, and returns the same value.</p>
<p>If we want to import these functions and use them in our program we would do
so like this:</p>
<pre><code class="language-rust noplaypen">pub external fn random_float() -&gt; Float = &quot;rand&quot; &quot;uniform&quot;

// Elixir modules start with `Elixir.`
pub external fn inspect(a) -&gt; a = &quot;Elixir.IO&quot; &quot;inspect&quot;
</code></pre>
<h2><a class="header" href="#labelled-arguments-1" id="labelled-arguments-1">Labelled arguments</a></h2>
<p>Like regular functions, external functions can have labelled arguments.</p>
<pre><code class="language-rust noplaypen">pub external fn any(in: List(a), satisfying: fn(a) -&gt; Bool) =
  &quot;my_external_module&quot; &quot;any&quot;
</code></pre>
<p>This function has the labelled arguments <code>in</code> and <code>satisfying</code>, and can be
called like so:</p>
<pre><code class="language-rust noplaypen">any(in: my_list, satisfying: is_even)
any(satisfying: is_even, in: my_list)
</code></pre>
<h1><a class="header" href="#external-type" id="external-type">External type</a></h1>
<p>In addition to importing external functions we can also import external types.
Gleam knows nothing about the runtime representation of these types and so
they cannot be pattern matched on, but they can be used with external
functions that know how to work with them.</p>
<p>Here is an example of importing a <code>Queue</code> data type and some functions from
Erlang's <code>queue</code> module to work with the new <code>Queue</code> type.</p>
<pre><code class="language-rust noplaypen">pub external type Queue(a)

pub external fn new() -&gt; Queue(a) = &quot;queue&quot; &quot;new&quot;

pub external fn length(Queue(a)) -&gt; Int = &quot;queue&quot; &quot;len&quot;

pub external fn push(Queue(a), a) -&gt; Queue(a) = &quot;queue&quot; &quot;in&quot;
</code></pre>
<h1><a class="header" href="#faqs" id="faqs">FAQs</a></h1>
<ul>
<li><a href="faqs.html#why-is-the-compiler-written-in-rust">Why is the compiler written in Rust?</a></li>
<li><a href="faqs.html#will-gleam-have-type-classes">Will Gleam have type classes?</a></li>
<li><a href="faqs.html#how-is-message-passing-typed">How is message passing typed?</a></li>
<li><a href="faqs.html#how-does-gleam-compare-to-alpaca">How does Gleam compare to Alpaca?</a></li>
<li><a href="faqs.html#should-i-put-gleam-in-production">Should I put Gleam in production?</a></li>
<li><a href="faqs.html#is-it-good">Is it good?</a></li>
</ul>
<h2><a class="header" href="#why-is-the-compiler-written-in-rust" id="why-is-the-compiler-written-in-rust">Why is the compiler written in Rust?</a></h2>
<p>Prototype versions of the Gleam compiler was written in Erlang, but a switch was
made to Rust as the lack of static types was making refactoring a slow and
error prone process. A full Rust rewrite of the prototype resulted in the
removal of a lot of tech debt and bugs, and the performance boost is nice too!</p>
<p>One day Gleam may have a compiler written in Gleam, but for now we are focused
on developing other areas of the language such as libraries, tooling, and
documentation.</p>
<h2><a class="header" href="#will-gleam-have-type-classes" id="will-gleam-have-type-classes">Will Gleam have type classes?</a></h2>
<p>Some form of ad-hoc polymorphism could be a good addition to the ergonomics of
the language, though what shape that may take is unclear. Type classes are one
option, OCaml style implicit modules are another, or perhaps it'll be
something else entirely.</p>
<h2><a class="header" href="#how-is-message-passing-typed" id="how-is-message-passing-typed">How is message passing typed?</a></h2>
<p>Gleam doesn't currently have first class support for the BEAM's
concurrency primitives such as <code>receive</code>, <code>send</code>, and <code>spawn</code>. This is because
research is still ongoing as to the best way to apply a strong type system to
them while still enabling established OTP patterns. For now these primitives
should be used via the Erlang FFI, making them dynamically typed.</p>
<p>Many OTP patterns such as <code>gen_server</code> are functional in nature and don't
require direct use of these primitives so these behaviours can be implemented
in Gleam today.</p>
<h2><a class="header" href="#how-does-gleam-compare-to-alpaca" id="how-does-gleam-compare-to-alpaca">How does Gleam compare to Alpaca?</a></h2>
<p><a href="https://github.com/alpaca-lang/alpaca">Alpaca</a> is similar to Gleam in that it is a statically typed language
for the Erlang VM that is inspired by the ML family of languages. It's a
wonderful project and we hope they are wildly successful!</p>
<p>Here's a non-exhaustive list of differences:</p>
<ul>
<li>Alpaca functions are auto-curried, Gleam's are not.</li>
<li>Alpaca's unions can be untagged, with Gleam all variants in an enum need a
name.</li>
<li>Alpaca's compiler is written in Erlang, Gleam's is written in Rust.</li>
<li>Alpaca's syntax is closer to ML family languages, Gleam's is closer to C
family languages.</li>
<li>Alpaca compiles to Core Erlang, Gleam compiles to regular Erlang.</li>
</ul>
<p>Alpaca is great, check it out! :)</p>
<h2><a class="header" href="#should-i-put-gleam-in-production" id="should-i-put-gleam-in-production">Should I put Gleam in production?</a></h2>
<p>Probably not. Gleam is a very young language and there may be all kinds of
problems and breaking changes down the line.</p>
<p>Having said that, the Erlang VM is extremely mature and well tested, and if
you decide to move away from Gleam the language you can compile your code to
Erlang and maintain that in future.</p>
<h2><a class="header" href="#is-it-good" id="is-it-good">Is it good?</a></h2>
<p>Yes, I think so. :)</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
